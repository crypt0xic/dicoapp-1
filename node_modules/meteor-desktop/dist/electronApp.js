"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asar = _interopRequireDefault(require("asar"));

var _assignIn = _interopRequireDefault(require("lodash/assignIn"));

var _lodash = _interopRequireDefault(require("lodash"));

var _installLocal = require("install-local");

var _core = require("@babel/core");

var _crypto = _interopRequireDefault(require("crypto"));

var _del = _interopRequireDefault(require("del"));

var _presetEnv = _interopRequireDefault(require("@babel/preset-env"));

var _fs = _interopRequireDefault(require("fs"));

var _glob = _interopRequireDefault(require("glob"));

var _path = _interopRequireDefault(require("path"));

var _shelljs = _interopRequireDefault(require("shelljs"));

var _crossSpawn = _interopRequireDefault(require("cross-spawn"));

var _semver = _interopRequireDefault(require("semver"));

var _uglifyEs = _interopRequireDefault(require("uglify-es"));

var _yarn = require("electron-builder-lib/out/util/yarn");

var _log = _interopRequireDefault(require("./log"));

var _electronAppScaffold = _interopRequireDefault(require("./electronAppScaffold"));

var _dependenciesManager = _interopRequireDefault(require("./dependenciesManager"));

var _binaryModulesDetector = _interopRequireDefault(require("./binaryModulesDetector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step("next", value); } function _throw(err) { step("throw", err); } _next(); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

_shelljs.default.config.fatal = true;
/**
 * Represents the .desktop dir scaffold.
 * @class
 */

var ElectronApp =
/*#__PURE__*/
function () {
  /**
   * @param {MeteorDesktop} $ - context
   * @constructor
   */
  function ElectronApp($) {
    _classCallCheck(this, ElectronApp);

    this.log = new _log.default('electronApp');
    this.scaffold = new _electronAppScaffold.default($);
    this.depsManager = new _dependenciesManager.default($, this.scaffold.getDefaultPackageJson().dependencies);
    this.$ = $;
    this.meteorApp = this.$.meteorApp;
    this.packageJson = null;
    this.version = null;
    this.compatibilityVersion = null;
  }
  /**
   * Makes an app.asar from the skeleton app.
   * @property {Array} excludeFromDel - list of paths to exclude from deleting
   * @returns {Promise}
   */


  _createClass(ElectronApp, [{
    key: "packSkeletonToAsar",
    value: function packSkeletonToAsar() {
      var _this = this;

      var excludeFromDel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.log.info('packing skeleton app and node_modules to asar archive');
      return new Promise(function (resolve) {
        var extract = _this.getModulesToExtract(); // We want to pack skeleton app and node_modules together, so we need to temporarily
        // move node_modules to app dir.


        _this.log.debug('moving node_modules to app dir');

        _fs.default.renameSync(_this.$.env.paths.electronApp.nodeModules, _path.default.join(_this.$.env.paths.electronApp.appRoot, 'node_modules'));

        var extracted = false;
        extracted = _this.extractModules(extract);

        _this.log.debug('packing');

        _asar.default.createPackage(_this.$.env.paths.electronApp.appRoot, _this.$.env.paths.electronApp.appAsar, function () {
          // Lets move the node_modules back.
          _this.log.debug('moving node_modules back from app dir');

          _shelljs.default.mv(_path.default.join(_this.$.env.paths.electronApp.appRoot, 'node_modules'), _this.$.env.paths.electronApp.nodeModules);

          if (extracted) {
            // We need to create a full node modules back. In other words we want
            // the extracted modules back.
            extract.forEach(function (module) {
              return _shelljs.default.cp('-rf', _path.default.join(_this.$.env.paths.electronApp.extractedNodeModules, module), _path.default.join(_this.$.env.paths.electronApp.nodeModules, module));
            }); // Get the .bin back.

            if (_this.$.utils.exists(_this.$.env.paths.electronApp.extractedNodeModulesBin)) {
              _shelljs.default.cp(_path.default.join(_this.$.env.paths.electronApp.extractedNodeModulesBin, '*'), _path.default.join(_this.$.env.paths.electronApp.nodeModules, '.bin'));
            }
          }

          _this.log.debug('deleting source files');

          var exclude = [_this.$.env.paths.electronApp.nodeModules].concat([_this.$.env.paths.electronApp.appAsar, _this.$.env.paths.electronApp.packageJson], excludeFromDel);

          _del.default.sync([`${_this.$.env.paths.electronApp.root}${_path.default.sep}*`].concat(exclude.map(function (pathToExclude) {
            return `!${pathToExclude}`;
          })));

          resolve();
        });
      });
    }
    /**
     * Moves specified node modules to a separate directory.
     * @param {Array} extract
     * @returns {boolean}
     */

  }, {
    key: "extractModules",
    value: function extractModules(extract) {
      var _this2 = this;

      var ext = ['.js', '.bat', '.sh', '.cmd', ''];

      if (extract.length > 0) {
        if (this.$.utils.exists(this.$.env.paths.electronApp.extractedNodeModules)) {
          _shelljs.default.rm('-rf', this.$.env.paths.electronApp.extractedNodeModules);
        }

        _fs.default.mkdirSync(this.$.env.paths.electronApp.extractedNodeModules);

        _fs.default.mkdirSync(this.$.env.paths.electronApp.extractedNodeModulesBin);

        extract.forEach(function (module) {
          _fs.default.renameSync(_path.default.join(_this2.$.env.paths.electronApp.appRoot, 'node_modules', module), _path.default.join(_this2.$.env.paths.electronApp.extractedNodeModules, module)); // Move bins.


          _this2.extractBin(module, ext);
        });
        return true;
      }

      return false;
    }
    /**
     * Extracts the bin files associated with a certain node modules.
     *
     * @param module
     * @param ext
     */

  }, {
    key: "extractBin",
    value: function extractBin(module, ext) {
      var _this3 = this;

      var packageJson;

      try {
        packageJson = JSON.parse(_fs.default.readFileSync(_path.default.join(this.$.env.paths.electronApp.extractedNodeModules, module, 'package.json'), 'utf8'));
      } catch (e) {
        packageJson = {};
      }

      var bins = 'bin' in packageJson && typeof packageJson.bin === 'object' ? Object.keys(packageJson.bin) : [];

      if (bins.length > 0) {
        bins.forEach(function (bin) {
          ext.forEach(function (extension) {
            var binFilePath = _path.default.join(_this3.$.env.paths.electronApp.appRoot, 'node_modules', '.bin', `${bin}${extension}`);

            if (_this3.$.utils.exists(binFilePath) || _this3.$.utils.symlinkExists(binFilePath)) {
              _fs.default.renameSync(binFilePath, _path.default.join(_this3.$.env.paths.electronApp.extractedNodeModulesBin, `${bin}${extension}`));
            }
          });
        });
      }
    }
    /**
     * Merges the `extract` field with automatically detected modules.
     */

  }, {
    key: "getModulesToExtract",
    value: function getModulesToExtract() {
      var binaryModulesDetector = new _binaryModulesDetector.default(this.$.env.paths.electronApp.nodeModules);
      var toBeExtracted = binaryModulesDetector.detect();

      var _$$desktop$getSetting = this.$.desktop.getSettings(),
          extract = _$$desktop$getSetting.extract;

      if (!Array.isArray(extract)) {
        extract = [];
      }

      var merge = {};
      toBeExtracted.concat(extract).forEach(function (module) {
        merge[module] = true;
      });
      extract = Object.keys(merge);

      if (extract.length > 0) {
        this.log.verbose(`resultant modules to extract list is: ${extract.join(', ')}`);
      }

      return extract;
    }
    /**
     * Calculates a md5 from all dependencies.
     */

  }, {
    key: "calculateCompatibilityVersion",
    value: function calculateCompatibilityVersion() {
      this.log.verbose('calculating compatibility version');
      var settings = this.$.desktop.getSettings();

      if ('desktopHCPCompatibilityVersion' in settings) {
        this.compatibilityVersion = `${settings.desktopHCPCompatibilityVersion}`;
        this.log.warn(`compatibility version overridden to ${this.compatibilityVersion}`);
        return;
      }

      var md5 = _crypto.default.createHash('md5');

      var dependencies = this.depsManager.getDependencies();
      var dependenciesSorted = Object.keys(dependencies).sort();
      dependencies = dependenciesSorted.map(function (dependency) {
        return `${dependency}:${dependencies[dependency]}`;
      });
      var mainCompatibilityVersion = this.$.getVersion().split('.');
      this.log.debug('meteor-desktop compatibility version is ', `${mainCompatibilityVersion[0]}.${mainCompatibilityVersion[1]}`);
      dependencies.push(`meteor-desktop:${mainCompatibilityVersion[0]}.${mainCompatibilityVersion[1]}`);
      var desktopCompatibilityVersion = settings.version.split('.')[0];
      this.log.debug('.desktop compatibility version is ', desktopCompatibilityVersion);
      dependencies.push(`desktop-app:${desktopCompatibilityVersion}`);

      if (process.env.METEOR_DESKTOP_DEBUG_DESKTOP_COMPATIBILITY_VERSION || process.env.METEOR_DESKTOP_DEBUG) {
        this.log.debug(`compatibility version calculated from ${JSON.stringify(dependencies)}`);
      }

      md5.update(JSON.stringify(dependencies));
      this.compatibilityVersion = md5.digest('hex');
    }
    /**
     * Runs all necessary tasks to build the desktopified app.
     */

  }, {
    key: "build",
    value: function () {
      var _build = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var run,
            nodeModulesRemoved,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                run = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;
                // TODO: refactor to a task runner
                this.log.info('scaffolding');

                if (!this.$.desktop.check()) {
                  if (!this.$.env.options.scaffold) {
                    this.log.error('seems that you do not have a .desktop dir in your project or it is' + ' corrupted. Run \'npm run desktop -- init\' to get a new one.'); // Do not fail, so that npm will not print his error stuff to console.

                    process.exit(0);
                  } else {
                    this.$.desktop.scaffold();
                    this.$.meteorApp.updateGitIgnore();
                  }
                }

                try {
                  this.$.meteorApp.updateGitIgnore();
                } catch (e) {
                  this.log.warn(`error occurred while adding ${this.$.env.paths.electronApp.rootName}` + 'to .gitignore: ', e);
                }

                _context.prev = 4;
                _context.next = 7;
                return this.$.meteorApp.ensureDesktopHCPPackages();

              case 7:
                _context.next = 13;
                break;

              case 9:
                _context.prev = 9;
                _context.t0 = _context["catch"](4);
                this.log.error('error while checking for required packages: ', _context.t0);
                process.exit(1);

              case 13:
                _context.prev = 13;
                _context.next = 16;
                return this.scaffold.make();

              case 16:
                _context.next = 22;
                break;

              case 18:
                _context.prev = 18;
                _context.t1 = _context["catch"](13);
                this.log.error('error while scaffolding: ', _context.t1);
                process.exit(1);

              case 22:
                try {
                  this.updatePackageJsonFields();
                } catch (e) {
                  this.log.error('error while updating package.json: ', e);
                }

                try {
                  this.updateDependenciesList();
                } catch (e) {
                  this.log.error('error while merging dependencies list: ', e);
                }

                try {
                  this.calculateCompatibilityVersion();
                } catch (e) {
                  this.log.error('error while calculating compatibility version: ', e);
                  process.exit(1);
                }

                _context.prev = 25;
                _context.next = 28;
                return this.handleTemporaryNodeModules();

              case 28:
                _context.next = 34;
                break;

              case 30:
                _context.prev = 30;
                _context.t2 = _context["catch"](25);
                this.log.error('error occurred while handling temporary node_modules: ', _context.t2);
                process.exit(1);

              case 34:
                _context.prev = 34;
                _context.next = 37;
                return this.handleStateOfNodeModules();

              case 37:
                nodeModulesRemoved = _context.sent;
                _context.next = 44;
                break;

              case 40:
                _context.prev = 40;
                _context.t3 = _context["catch"](34);
                this.log.error('error occurred while clearing node_modules: ', _context.t3);
                process.exit(1);

              case 44:
                _context.prev = 44;
                _context.next = 47;
                return this.linkNpmPackages();

              case 47:
                _context.next = 53;
                break;

              case 49:
                _context.prev = 49;
                _context.t4 = _context["catch"](44);
                this.log.error(`linking packages failed: ${_context.t4}`);
                process.exit(1);

              case 53:
                _context.prev = 53;
                _context.next = 56;
                return this.rebuildDeps(true);

              case 56:
                _context.next = 62;
                break;

              case 58:
                _context.prev = 58;
                _context.t5 = _context["catch"](53);
                this.log.error('error occurred while installing node_modules: ', _context.t5);
                process.exit(1);

              case 62:
                if (nodeModulesRemoved) {
                  _context.next = 72;
                  break;
                }

                _context.prev = 63;
                _context.next = 66;
                return this.rebuildDeps();

              case 66:
                _context.next = 72;
                break;

              case 68:
                _context.prev = 68;
                _context.t6 = _context["catch"](63);
                this.log.error('error occurred while rebuilding native node modules: ', _context.t6);
                process.exit(1);

              case 72:
                _context.prev = 72;
                _context.next = 75;
                return this.installLocalNodeModules();

              case 75:
                _context.next = 81;
                break;

              case 77:
                _context.prev = 77;
                _context.t7 = _context["catch"](72);
                this.log.error('error occurred while installing local node modules: ', _context.t7);
                process.exit(1);

              case 81:
                _context.prev = 81;
                _context.next = 84;
                return this.ensureMeteorDependencies();

              case 84:
                _context.next = 90;
                break;

              case 86:
                _context.prev = 86;
                _context.t8 = _context["catch"](81);
                this.log.error('error occurred while ensuring meteor dependencies are installed: ', _context.t8);
                process.exit(1);

              case 90:
                if (!this.$.env.isProductionBuild()) {
                  _context.next = 100;
                  break;
                }

                _context.prev = 91;
                _context.next = 94;
                return this.packSkeletonToAsar();

              case 94:
                _context.next = 100;
                break;

              case 96:
                _context.prev = 96;
                _context.t9 = _context["catch"](91);
                this.log.error('error while packing skeleton to asar: ', _context.t9);
                process.exit(1);

              case 100:
                // TODO: find a way to avoid copying .desktop to a temp location
                try {
                  this.copyDesktopToDesktopTemp();
                } catch (e) {
                  this.log.error('error while copying .desktop to a temporary location: ', e);
                  process.exit(1);
                }

                try {
                  this.updateSettingsJsonFields();
                } catch (e) {
                  this.log.error('error while updating settings.json: ', e);
                  process.exit(1);
                }

                _context.prev = 102;
                _context.next = 105;
                return this.excludeFilesFromArchive();

              case 105:
                _context.next = 111;
                break;

              case 107:
                _context.prev = 107;
                _context.t10 = _context["catch"](102);
                this.log.error('error while excluding files from packing to asar: ', _context.t10);
                process.exit(1);

              case 111:
                try {
                  this.transpileAndMinify();
                } catch (e) {
                  this.log.error('error while transpiling or minifying: ', e);
                }

                _context.prev = 112;
                _context.next = 115;
                return this.packDesktopToAsar();

              case 115:
                _context.next = 121;
                break;

              case 117:
                _context.prev = 117;
                _context.t11 = _context["catch"](112);
                this.log.error('error occurred while packing .desktop to asar: ', _context.t11);
                process.exit(1);

              case 121:
                _context.prev = 121;
                _context.next = 124;
                return this.getMeteorClientBuild();

              case 124:
                _context.next = 129;
                break;

              case 126:
                _context.prev = 126;
                _context.t12 = _context["catch"](121);
                this.log.error('error occurred during getting meteor mobile build: ', _context.t12);

              case 129:
                if (run) {
                  this.log.info('running');
                  this.$.electron.run();
                } else {
                  this.log.info('built');
                }

              case 130:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 9], [13, 18], [25, 30], [34, 40], [44, 49], [53, 58], [63, 68], [72, 77], [81, 86], [91, 96], [102, 107], [112, 117], [121, 126]]);
      }));

      return function build() {
        return _build.apply(this, arguments);
      };
    }()
    /**
     * Ensures all required dependencies are added to the Meteor project.
     * @returns {Promise.<void>}
     */

  }, {
    key: "ensureMeteorDependencies",
    value: function () {
      var _ensureMeteorDependencies = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _this4 = this;

        var packages, packagesWithVersion, plugins;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                packages = [];
                packagesWithVersion = [];
                plugins = 'plugins [';
                Object.keys(this.$.desktop.getDependencies().plugins).forEach(function (plugin) {
                  // Read package.json of the plugin.
                  var packageJson = JSON.parse(_fs.default.readFileSync(_path.default.join(_this4.$.env.paths.electronApp.nodeModules, plugin, 'package.json'), 'utf8'));

                  if ('meteorDependencies' in packageJson && typeof packageJson.meteorDependencies === 'object') {
                    plugins += `${plugin}, `;
                    packages.unshift.apply(packages, _toConsumableArray(Object.keys(packageJson.meteorDependencies)));
                    packagesWithVersion.unshift.apply(packagesWithVersion, _toConsumableArray(packages.map(function (packageName) {
                      if (packageJson.meteorDependencies[packageName] === '@version') {
                        return `${packageName}@${packageJson.version}`;
                      }

                      return `${packageName}@${packageJson.meteorDependencies[packageName]}`;
                    })));
                  }
                });

                if (!(packages.length > 0)) {
                  _context2.next = 14;
                  break;
                }

                plugins = `${plugins.substr(0, plugins.length - 2)}]`;
                _context2.prev = 6;
                _context2.next = 9;
                return this.$.meteorApp.meteorManager.ensurePackages(packages, packagesWithVersion, plugins);

              case 9:
                _context2.next = 14;
                break;

              case 11:
                _context2.prev = 11;
                _context2.t0 = _context2["catch"](6);
                throw new Error(_context2.t0);

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 11]]);
      }));

      return function ensureMeteorDependencies() {
        return _ensureMeteorDependencies.apply(this, arguments);
      };
    }()
    /**
     * Builds meteor app.
     */

  }, {
    key: "getMeteorClientBuild",
    value: function () {
      var _getMeteorClientBuild = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.$.meteorApp.build();

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function getMeteorClientBuild() {
        return _getMeteorClientBuild.apply(this, arguments);
      };
    }()
    /**
     * Removes node_modules if needed.
     * @returns {Promise<void>}
     */

  }, {
    key: "handleStateOfNodeModules",
    value: function () {
      var _handleStateOfNodeModules = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(this.$.env.isProductionBuild() || this.$.env.options.ia32)) {
                  _context4.next = 11;
                  break;
                }

                if (!this.$.env.isProductionBuild()) {
                  this.log.info('clearing node_modules because we need to have it clear for ia32 rebuild');
                } else {
                  this.log.info('clearing node_modules because this is a production build');
                }

                _context4.prev = 2;
                _context4.next = 5;
                return this.$.utils.rmWithRetries('-rf', this.$.env.paths.electronApp.nodeModules);

              case 5:
                _context4.next = 10;
                break;

              case 7:
                _context4.prev = 7;
                _context4.t0 = _context4["catch"](2);
                throw new Error(_context4.t0);

              case 10:
                return _context4.abrupt("return", true);

              case 11:
                return _context4.abrupt("return", false);

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[2, 7]]);
      }));

      return function handleStateOfNodeModules() {
        return _handleStateOfNodeModules.apply(this, arguments);
      };
    }()
    /**
     * If there is a temporary node_modules folder and no node_modules folder, we will
     * restore it, as it might be a leftover from an interrupted flow.
     * @returns {Promise<void>}
     */

  }, {
    key: "handleTemporaryNodeModules",
    value: function () {
      var _handleTemporaryNodeModules = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.$.utils.exists(this.$.env.paths.electronApp.tmpNodeModules)) {
                  _context5.next = 15;
                  break;
                }

                if (this.$.utils.exists(this.$.env.paths.electronApp.nodeModules)) {
                  _context5.next = 6;
                  break;
                }

                this.log.debug('moving temp node_modules back');

                _shelljs.default.mv(this.$.env.paths.electronApp.tmpNodeModules, this.$.env.paths.electronApp.nodeModules);

                _context5.next = 15;
                break;

              case 6:
                // If there is a node_modules folder, we should clear the temporary one.
                this.log.debug('clearing temp node_modules because new one is already created');
                _context5.prev = 7;
                _context5.next = 10;
                return this.$.utils.rmWithRetries('-rf', this.$.env.paths.electronApp.tmpNodeModules);

              case 10:
                _context5.next = 15;
                break;

              case 12:
                _context5.prev = 12;
                _context5.t0 = _context5["catch"](7);
                throw new Error(_context5.t0);

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this, [[7, 12]]);
      }));

      return function handleTemporaryNodeModules() {
        return _handleTemporaryNodeModules.apply(this, arguments);
      };
    }()
    /**
     * NOT IN USE RIGHT NOW // DEPRECATED
     *
     * Wrapper for spawning npm.
     * @param {Array}  commands - commands for spawn
     * @param {string} stdio
     * @return {Promise}
     */

  }, {
    key: "runNpm",
    value: function runNpm(commands) {
      var _this5 = this;

      var stdio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ignore';
      return new Promise(function (resolve, reject) {
        // TODO: find a way to run npm without depending on it cause it's a huge dependency.
        var npm = _path.default.join(_this5.$.env.paths.meteorApp.root, 'node_modules', '.bin', 'npm');

        if (!_this5.$.utils.exists(npm)) {
          npm = _path.default.join(_this5.$.env.paths.meteorApp.root, 'node_modules', 'meteor-desktop', 'node_modules', '.bin', 'npm');
        }

        if (!_this5.$.utils.exists(npm)) {
          npm = _shelljs.default.which('npm');
        }

        _this5.log.verbose(`executing npm ${commands.join(' ')}`);

        (0, _crossSpawn.default)(npm, commands, {
          cwd: _this5.$.env.paths.electronApp.root,
          stdio
        }).on('exit', function (code) {
          return code === 0 ? resolve() : reject(new Error(`npm exit code was ${code}`));
        });
      });
    }
    /**
     * Runs npm link for every package specified in settings.json->linkPackages.
     */

  }, {
    key: "linkNpmPackages",
    value: function () {
      var _linkNpmPackages = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var _this6 = this;

        var settings, promises;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                settings = this.$.desktop.getSettings();
                promises = [];

                if ('linkPackages' in this.$.desktop.getSettings()) {
                  if (Array.isArray(settings.linkPackages)) {
                    settings.linkPackages.forEach(function (packageName) {
                      return promises.push(_this6.runNpm(['link', packageName]));
                    });
                  }
                }

                _context6.next = 5;
                return Promise.all(promises);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function linkNpmPackages() {
        return _linkNpmPackages.apply(this, arguments);
      };
    }()
    /**
     * Runs npm in the electron app to get the dependencies installed.
     * @returns {Promise}
     */

  }, {
    key: "ensureDeps",
    value: function () {
      var _ensureDeps = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this.log.info('installing dependencies');

                if (!this.$.utils.exists(this.$.env.paths.electronApp.nodeModules)) {
                  _context7.next = 11;
                  break;
                }

                this.log.debug('running npm prune to wipe unneeded dependencies');
                _context7.prev = 3;
                _context7.next = 6;
                return this.runNpm(['prune']);

              case 6:
                _context7.next = 11;
                break;

              case 8:
                _context7.prev = 8;
                _context7.t0 = _context7["catch"](3);
                throw new Error(_context7.t0);

              case 11:
                _context7.prev = 11;
                _context7.next = 14;
                return this.runNpm(['install'], this.$.env.stdio);

              case 14:
                _context7.next = 19;
                break;

              case 16:
                _context7.prev = 16;
                _context7.t1 = _context7["catch"](11);
                throw new Error(_context7.t1);

              case 19:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 8], [11, 16]]);
      }));

      return function ensureDeps() {
        return _ensureDeps.apply(this, arguments);
      };
    }()
    /**
     * Warns if plugins version are outdated in compare to the newest scaffold.
     * @param {Object} pluginsVersions - current plugins versions from settings.json
     */

  }, {
    key: "checkPluginsVersion",
    value: function checkPluginsVersion(pluginsVersions) {
      var _this7 = this;

      var settingsJson = JSON.parse(_fs.default.readFileSync(_path.default.join(this.$.env.paths.scaffold, 'settings.json')));
      var scaffoldPluginsVersion = this.$.desktop.getDependencies(settingsJson, false).plugins;
      Object.keys(pluginsVersions).forEach(function (pluginName) {
        if (pluginName in scaffoldPluginsVersion && scaffoldPluginsVersion[pluginName] !== pluginsVersions[pluginName] && _semver.default.lt(pluginsVersions[pluginName], scaffoldPluginsVersion[pluginName])) {
          _this7.log.warn(`you are using outdated version ${pluginsVersions[pluginName]} of ` + `${pluginName}, the suggested version to use is ` + `${scaffoldPluginsVersion[pluginName]}`);
        }
      });
    }
    /**
     * Merges core dependency list with the dependencies from .desktop.
     */

  }, {
    key: "updateDependenciesList",
    value: function updateDependenciesList() {
      var _this8 = this;

      this.log.info('updating list of package.json\'s dependencies');
      var desktopDependencies = this.$.desktop.getDependencies();
      this.checkPluginsVersion(desktopDependencies.plugins);
      this.log.debug('merging settings.json[dependencies]');
      this.depsManager.mergeDependencies('settings.json[dependencies]', desktopDependencies.fromSettings);
      this.log.debug('merging settings.json[plugins]');
      this.depsManager.mergeDependencies('settings.json[plugins]', desktopDependencies.plugins);
      this.log.debug('merging dependencies from modules');
      Object.keys(desktopDependencies.modules).forEach(function (module) {
        return _this8.depsManager.mergeDependencies(`module[${module}]`, desktopDependencies.modules[module]);
      });
      this.packageJson.dependencies = this.depsManager.getRemoteDependencies();
      this.packageJson.localDependencies = this.depsManager.getLocalDependencies();
      this.log.debug('writing updated package.json');

      _fs.default.writeFileSync(this.$.env.paths.electronApp.packageJson, JSON.stringify(this.packageJson, null, 2));
    }
    /**
     * Install node modules from local paths using local-install.
     *
     * @param {string} arch
     * @returns {Promise}
     */

  }, {
    key: "installLocalNodeModules",
    value: function installLocalNodeModules() {
      var arch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.$.env.options.ia32 || process.arch === 'ia32' ? 'ia32' : 'x64';

      var localDependencies = _lodash.default.values(this.packageJson.localDependencies);

      if (localDependencies.length === 0) {
        return Promise.resolve();
      }

      this.log.info('installing local node modules');
      var lastRebuild = this.$.electronBuilder.prepareLastRebuildObject(arch);
      var env = (0, _yarn.getGypEnv)(lastRebuild.frameworkInfo, lastRebuild.platform, lastRebuild.arch);
      var installer = new _installLocal.LocalInstaller({
        [this.$.env.paths.electronApp.root]: localDependencies
      }, {
        npmEnv: env
      });
      (0, _installLocal.progress)(installer);
      return installer.install();
    }
    /**
     * Rebuild binary dependencies against Electron's node headers.
     * @returns {Promise}
     */

  }, {
    key: "rebuildDeps",
    value: function rebuildDeps() {
      var install = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (install) {
        this.log.info('issuing node_modules install from electron-builder');
      } else {
        this.log.info('issuing native modules rebuild from electron-builder');
      }

      var arch = this.$.env.options.ia32 || process.arch === 'ia32' ? 'ia32' : 'x64';

      if (this.$.env.options.ia32) {
        this.log.verbose('forcing rebuild for 32bit');
      } else {
        this.log.verbose(`rebuilding for ${arch}`);
      }

      return this.$.electronBuilder.installOrRebuild(arch, undefined, install);
    }
    /**
     * Update package.json fields accordingly to what is set in settings.json.
     *
     * packageJson.name = settings.projectName
     * packageJson.version = settings.version
     * packageJson.* = settings.packageJsonFields
     */

  }, {
    key: "updatePackageJsonFields",
    value: function updatePackageJsonFields() {
      this.log.verbose('updating package.json fields');
      var settings = this.$.desktop.getSettings();
      /** @type {desktopSettings} */

      var packageJson = this.scaffold.getDefaultPackageJson();
      packageJson.version = settings.version;

      if ('packageJsonFields' in settings) {
        (0, _assignIn.default)(packageJson, settings.packageJsonFields);
      }

      (0, _assignIn.default)(packageJson, {
        name: settings.projectName
      });
      this.log.debug('writing updated package.json');

      _fs.default.writeFileSync(this.$.env.paths.electronApp.packageJson, JSON.stringify(packageJson, null, 4));

      this.packageJson = packageJson;
    }
    /**
     * Updates settings.json with env (prod/dev) information and versions.
     */

  }, {
    key: "updateSettingsJsonFields",
    value: function updateSettingsJsonFields() {
      this.log.debug('updating settings.json fields');
      var settings = this.$.desktop.getSettings(); // Save versions.

      settings.compatibilityVersion = this.compatibilityVersion; // Pass information about build type to the settings.json.

      settings.env = this.$.env.isProductionBuild() ? 'prod' : 'dev';
      settings.desktopVersion = `${this.$.desktop.getHashVersion()}_${settings.env}`;
      settings.meteorDesktopVersion = this.$.getVersion();

      _fs.default.writeFileSync(this.$.env.paths.desktopTmp.settings, JSON.stringify(settings, null, 4));
    }
    /**
     * Copies files from prepared .desktop to desktop.asar in electron app.
     */

  }, {
    key: "packDesktopToAsar",
    value: function packDesktopToAsar() {
      var _this9 = this;

      this.log.info('packing .desktop to asar');
      return new Promise(function (resolve, reject) {
        _asar.default.createPackage(_this9.$.env.paths.desktopTmp.root, _this9.$.env.paths.electronApp.desktopAsar, function () {
          _this9.log.verbose('clearing temporary .desktop');

          _this9.$.utils.rmWithRetries('-rf', _this9.$.env.paths.desktopTmp.root).then(function () {
            resolve();
          }).catch(function (e) {
            reject(e);
          });

          resolve();
        });
      });
    }
    /**
     * Makes a temporary copy of .desktop.
     */

  }, {
    key: "copyDesktopToDesktopTemp",
    value: function copyDesktopToDesktopTemp() {
      this.log.verbose('copying .desktop to temporary location');

      _shelljs.default.cp('-rf', this.$.env.paths.desktop.root, this.$.env.paths.desktopTmp.root); // Remove test files.


      _del.default.sync([_path.default.join(this.$.env.paths.desktopTmp.root, '**', '*.test.js')]);
    }
    /**
     * Runs babel and uglify over .desktop if requested.
     */

  }, {
    key: "transpileAndMinify",
    value: function transpileAndMinify() {
      this.log.info('transpiling and uglifying');
      var settings = this.$.desktop.getSettings();
      var options = 'uglifyOptions' in settings ? settings.uglifyOptions : {};
      var uglifyingEnabled = 'uglify' in settings && !!settings.uglify;
      var preset = (0, _presetEnv.default)(undefined, {
        targets: {
          node: '8'
        }
      });

      _glob.default.sync(`${this.$.env.paths.desktopTmp.root}/**/*.js`).forEach(function (file) {
        var _transformFileSync = (0, _core.transformFileSync)(file, {
          presets: [preset]
        }),
            code = _transformFileSync.code;

        var error;

        if (settings.env === 'prod' && uglifyingEnabled) {
          var _uglify$minify = _uglifyEs.default.minify(code, options);

          code = _uglify$minify.code;
          error = _uglify$minify.error;
        }

        if (error) {
          throw new Error(error);
        }

        _fs.default.writeFileSync(file, code);
      });
    }
    /**
     * Moves all the files that should not be packed into asar into a safe location which is the
     * 'extracted' dir in the electron app.
     */

  }, {
    key: "excludeFilesFromArchive",
    value: function () {
      var _excludeFilesFromArchive = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8() {
        var _this10 = this;

        var configs;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this.log.info('excluding files from packing'); // Ensure empty `extracted` dir

                _context8.prev = 1;
                _context8.next = 4;
                return this.$.utils.rmWithRetries('-rf', this.$.env.paths.electronApp.extracted);

              case 4:
                _context8.next = 9;
                break;

              case 6:
                _context8.prev = 6;
                _context8.t0 = _context8["catch"](1);
                throw new Error(_context8.t0);

              case 9:
                _shelljs.default.mkdir(this.$.env.paths.electronApp.extracted);

                configs = this.$.desktop.gatherModuleConfigs(); // Move files that should not be asar'ed.

                configs.forEach(function (config) {
                  var moduleConfig = config;

                  if ('extract' in moduleConfig) {
                    if (!Array.isArray(moduleConfig.extract)) {
                      moduleConfig.extract = [moduleConfig.extract];
                    }

                    moduleConfig.extract.forEach(function (file) {
                      _this10.log.debug(`excluding ${file} from ${config.name}`);

                      var filePath = _path.default.join(_this10.$.env.paths.desktopTmp.modules, moduleConfig.dirName, file);

                      var destinationPath = _path.default.join(_this10.$.env.paths.electronApp.extracted, moduleConfig.dirName);

                      if (!_this10.$.utils.exists(destinationPath)) {
                        _shelljs.default.mkdir(destinationPath);
                      }

                      _shelljs.default.mv(filePath, destinationPath);
                    });
                  }
                });

              case 12:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[1, 6]]);
      }));

      return function excludeFilesFromArchive() {
        return _excludeFilesFromArchive.apply(this, arguments);
      };
    }()
  }]);

  return ElectronApp;
}();

exports.default = ElectronApp;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi9lbGVjdHJvbkFwcC5qcyJdLCJuYW1lcyI6WyJjb25maWciLCJmYXRhbCIsIkVsZWN0cm9uQXBwIiwiJCIsImxvZyIsInNjYWZmb2xkIiwiZGVwc01hbmFnZXIiLCJnZXREZWZhdWx0UGFja2FnZUpzb24iLCJkZXBlbmRlbmNpZXMiLCJtZXRlb3JBcHAiLCJwYWNrYWdlSnNvbiIsInZlcnNpb24iLCJjb21wYXRpYmlsaXR5VmVyc2lvbiIsImV4Y2x1ZGVGcm9tRGVsIiwiaW5mbyIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXh0cmFjdCIsImdldE1vZHVsZXNUb0V4dHJhY3QiLCJkZWJ1ZyIsInJlbmFtZVN5bmMiLCJlbnYiLCJwYXRocyIsImVsZWN0cm9uQXBwIiwibm9kZU1vZHVsZXMiLCJqb2luIiwiYXBwUm9vdCIsImV4dHJhY3RlZCIsImV4dHJhY3RNb2R1bGVzIiwiY3JlYXRlUGFja2FnZSIsImFwcEFzYXIiLCJtdiIsImZvckVhY2giLCJjcCIsImV4dHJhY3RlZE5vZGVNb2R1bGVzIiwibW9kdWxlIiwidXRpbHMiLCJleGlzdHMiLCJleHRyYWN0ZWROb2RlTW9kdWxlc0JpbiIsImV4Y2x1ZGUiLCJjb25jYXQiLCJzeW5jIiwicm9vdCIsInNlcCIsIm1hcCIsInBhdGhUb0V4Y2x1ZGUiLCJleHQiLCJsZW5ndGgiLCJybSIsIm1rZGlyU3luYyIsImV4dHJhY3RCaW4iLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJlIiwiYmlucyIsImJpbiIsIk9iamVjdCIsImtleXMiLCJleHRlbnNpb24iLCJiaW5GaWxlUGF0aCIsInN5bWxpbmtFeGlzdHMiLCJiaW5hcnlNb2R1bGVzRGV0ZWN0b3IiLCJ0b0JlRXh0cmFjdGVkIiwiZGV0ZWN0IiwiZGVza3RvcCIsImdldFNldHRpbmdzIiwiQXJyYXkiLCJpc0FycmF5IiwibWVyZ2UiLCJ2ZXJib3NlIiwic2V0dGluZ3MiLCJkZXNrdG9wSENQQ29tcGF0aWJpbGl0eVZlcnNpb24iLCJ3YXJuIiwibWQ1IiwiY3JlYXRlSGFzaCIsImdldERlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llc1NvcnRlZCIsInNvcnQiLCJkZXBlbmRlbmN5IiwibWFpbkNvbXBhdGliaWxpdHlWZXJzaW9uIiwiZ2V0VmVyc2lvbiIsInNwbGl0IiwicHVzaCIsImRlc2t0b3BDb21wYXRpYmlsaXR5VmVyc2lvbiIsInByb2Nlc3MiLCJNRVRFT1JfREVTS1RPUF9ERUJVR19ERVNLVE9QX0NPTVBBVElCSUxJVFlfVkVSU0lPTiIsIk1FVEVPUl9ERVNLVE9QX0RFQlVHIiwic3RyaW5naWZ5IiwidXBkYXRlIiwiZGlnZXN0IiwicnVuIiwiY2hlY2siLCJvcHRpb25zIiwiZXJyb3IiLCJleGl0IiwidXBkYXRlR2l0SWdub3JlIiwicm9vdE5hbWUiLCJlbnN1cmVEZXNrdG9wSENQUGFja2FnZXMiLCJtYWtlIiwidXBkYXRlUGFja2FnZUpzb25GaWVsZHMiLCJ1cGRhdGVEZXBlbmRlbmNpZXNMaXN0IiwiY2FsY3VsYXRlQ29tcGF0aWJpbGl0eVZlcnNpb24iLCJoYW5kbGVUZW1wb3JhcnlOb2RlTW9kdWxlcyIsImhhbmRsZVN0YXRlT2ZOb2RlTW9kdWxlcyIsIm5vZGVNb2R1bGVzUmVtb3ZlZCIsImxpbmtOcG1QYWNrYWdlcyIsInJlYnVpbGREZXBzIiwiaW5zdGFsbExvY2FsTm9kZU1vZHVsZXMiLCJlbnN1cmVNZXRlb3JEZXBlbmRlbmNpZXMiLCJpc1Byb2R1Y3Rpb25CdWlsZCIsInBhY2tTa2VsZXRvblRvQXNhciIsImNvcHlEZXNrdG9wVG9EZXNrdG9wVGVtcCIsInVwZGF0ZVNldHRpbmdzSnNvbkZpZWxkcyIsImV4Y2x1ZGVGaWxlc0Zyb21BcmNoaXZlIiwidHJhbnNwaWxlQW5kTWluaWZ5IiwicGFja0Rlc2t0b3BUb0FzYXIiLCJnZXRNZXRlb3JDbGllbnRCdWlsZCIsImVsZWN0cm9uIiwicGFja2FnZXMiLCJwYWNrYWdlc1dpdGhWZXJzaW9uIiwicGx1Z2lucyIsInBsdWdpbiIsIm1ldGVvckRlcGVuZGVuY2llcyIsInVuc2hpZnQiLCJwYWNrYWdlTmFtZSIsInN1YnN0ciIsIm1ldGVvck1hbmFnZXIiLCJlbnN1cmVQYWNrYWdlcyIsIkVycm9yIiwiYnVpbGQiLCJpYTMyIiwicm1XaXRoUmV0cmllcyIsInRtcE5vZGVNb2R1bGVzIiwiY29tbWFuZHMiLCJzdGRpbyIsInJlamVjdCIsIm5wbSIsIndoaWNoIiwiY3dkIiwib24iLCJjb2RlIiwicHJvbWlzZXMiLCJsaW5rUGFja2FnZXMiLCJydW5OcG0iLCJhbGwiLCJwbHVnaW5zVmVyc2lvbnMiLCJzZXR0aW5nc0pzb24iLCJzY2FmZm9sZFBsdWdpbnNWZXJzaW9uIiwicGx1Z2luTmFtZSIsImx0IiwiZGVza3RvcERlcGVuZGVuY2llcyIsImNoZWNrUGx1Z2luc1ZlcnNpb24iLCJtZXJnZURlcGVuZGVuY2llcyIsImZyb21TZXR0aW5ncyIsIm1vZHVsZXMiLCJnZXRSZW1vdGVEZXBlbmRlbmNpZXMiLCJsb2NhbERlcGVuZGVuY2llcyIsImdldExvY2FsRGVwZW5kZW5jaWVzIiwid3JpdGVGaWxlU3luYyIsImFyY2giLCJ2YWx1ZXMiLCJsYXN0UmVidWlsZCIsImVsZWN0cm9uQnVpbGRlciIsInByZXBhcmVMYXN0UmVidWlsZE9iamVjdCIsImZyYW1ld29ya0luZm8iLCJwbGF0Zm9ybSIsImluc3RhbGxlciIsIm5wbUVudiIsImluc3RhbGwiLCJpbnN0YWxsT3JSZWJ1aWxkIiwidW5kZWZpbmVkIiwicGFja2FnZUpzb25GaWVsZHMiLCJuYW1lIiwicHJvamVjdE5hbWUiLCJkZXNrdG9wVmVyc2lvbiIsImdldEhhc2hWZXJzaW9uIiwibWV0ZW9yRGVza3RvcFZlcnNpb24iLCJkZXNrdG9wVG1wIiwiZGVza3RvcEFzYXIiLCJ0aGVuIiwiY2F0Y2giLCJ1Z2xpZnlPcHRpb25zIiwidWdsaWZ5aW5nRW5hYmxlZCIsInVnbGlmeSIsInByZXNldCIsInRhcmdldHMiLCJub2RlIiwiZmlsZSIsInByZXNldHMiLCJtaW5pZnkiLCJta2RpciIsImNvbmZpZ3MiLCJnYXRoZXJNb2R1bGVDb25maWdzIiwibW9kdWxlQ29uZmlnIiwiZmlsZVBhdGgiLCJkaXJOYW1lIiwiZGVzdGluYXRpb25QYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsaUJBQU1BLE1BQU4sQ0FBYUMsS0FBYixHQUFxQixJQUFyQjtBQUVBOzs7OztJQUlxQkMsVzs7O0FBQ2pCOzs7O0FBSUEsdUJBQVlDLENBQVosRUFBZTtBQUFBOztBQUNYLFNBQUtDLEdBQUwsR0FBVyxpQkFBUSxhQUFSLENBQVg7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLGlDQUF3QkYsQ0FBeEIsQ0FBaEI7QUFDQSxTQUFLRyxXQUFMLEdBQW1CLGlDQUNmSCxDQURlLEVBRWYsS0FBS0UsUUFBTCxDQUFjRSxxQkFBZCxHQUFzQ0MsWUFGdkIsQ0FBbkI7QUFJQSxTQUFLTCxDQUFMLEdBQVNBLENBQVQ7QUFDQSxTQUFLTSxTQUFMLEdBQWlCLEtBQUtOLENBQUwsQ0FBT00sU0FBeEI7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxTQUFLQyxvQkFBTCxHQUE0QixJQUE1QjtBQUNIO0FBRUQ7Ozs7Ozs7Ozt5Q0FLd0M7QUFBQTs7QUFBQSxVQUFyQkMsY0FBcUIsdUVBQUosRUFBSTtBQUNwQyxXQUFLVCxHQUFMLENBQVNVLElBQVQsQ0FBYyx1REFBZDtBQUNBLGFBQU8sSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBYTtBQUM1QixZQUFNQyxVQUFVLE1BQUtDLG1CQUFMLEVBQWhCLENBRDRCLENBRzVCO0FBQ0E7OztBQUNBLGNBQUtkLEdBQUwsQ0FBU2UsS0FBVCxDQUFlLGdDQUFmOztBQUVBLG9CQUFHQyxVQUFILENBQ0ksTUFBS2pCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJDLFdBRGpDLEVBRUksY0FBS0MsSUFBTCxDQUFVLE1BQUt0QixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCRyxPQUF2QyxFQUFnRCxjQUFoRCxDQUZKOztBQUtBLFlBQUlDLFlBQVksS0FBaEI7QUFDQUEsb0JBQVksTUFBS0MsY0FBTCxDQUFvQlgsT0FBcEIsQ0FBWjs7QUFFQSxjQUFLYixHQUFMLENBQVNlLEtBQVQsQ0FBZSxTQUFmOztBQUNBLHNCQUFLVSxhQUFMLENBQ0ksTUFBSzFCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJHLE9BRGpDLEVBRUksTUFBS3ZCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJPLE9BRmpDLEVBR0ksWUFBTTtBQUNGO0FBQ0EsZ0JBQUsxQixHQUFMLENBQVNlLEtBQVQsQ0FBZSx1Q0FBZjs7QUFFQSwyQkFBTVksRUFBTixDQUNJLGNBQUtOLElBQUwsQ0FBVSxNQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QkcsT0FBdkMsRUFBZ0QsY0FBaEQsQ0FESixFQUVJLE1BQUt2QixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCQyxXQUZqQzs7QUFLQSxjQUFJRyxTQUFKLEVBQWU7QUFDWDtBQUNBO0FBQ0FWLG9CQUFRZSxPQUFSLENBQWdCO0FBQUEscUJBQVUsaUJBQU1DLEVBQU4sQ0FDdEIsS0FEc0IsRUFFdEIsY0FBS1IsSUFBTCxDQUFVLE1BQUt0QixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCVyxvQkFBdkMsRUFBNkRDLE1BQTdELENBRnNCLEVBR3RCLGNBQUtWLElBQUwsQ0FBVSxNQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QkMsV0FBdkMsRUFBb0RXLE1BQXBELENBSHNCLENBQVY7QUFBQSxhQUFoQixFQUhXLENBU1g7O0FBQ0EsZ0JBQUksTUFBS2hDLENBQUwsQ0FBT2lDLEtBQVAsQ0FBYUMsTUFBYixDQUNBLE1BQUtsQyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCZSx1QkFEN0IsQ0FBSixFQUVHO0FBQ0MsK0JBQU1MLEVBQU4sQ0FDSSxjQUFLUixJQUFMLENBQVUsTUFBS3RCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJlLHVCQUF2QyxFQUFnRSxHQUFoRSxDQURKLEVBRUksY0FBS2IsSUFBTCxDQUFVLE1BQUt0QixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCQyxXQUF2QyxFQUFvRCxNQUFwRCxDQUZKO0FBSUg7QUFDSjs7QUFFRCxnQkFBS3BCLEdBQUwsQ0FBU2UsS0FBVCxDQUFlLHVCQUFmOztBQUNBLGNBQU1vQixVQUFVLENBQUMsTUFBS3BDLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJDLFdBQTlCLEVBQTJDZ0IsTUFBM0MsQ0FDWixDQUNJLE1BQUtyQyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCTyxPQURqQyxFQUVJLE1BQUszQixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCYixXQUZqQyxDQURZLEVBS1pHLGNBTFksQ0FBaEI7O0FBUUEsdUJBQUk0QixJQUFKLENBQ0ksQ0FBRSxHQUFFLE1BQUt0QyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCbUIsSUFBSyxHQUFFLGNBQUtDLEdBQUksR0FBakQsRUFBcURILE1BQXJELENBQ0lELFFBQVFLLEdBQVIsQ0FBWTtBQUFBLG1CQUFrQixJQUFHQyxhQUFjLEVBQW5DO0FBQUEsV0FBWixDQURKLENBREo7O0FBS0E3QjtBQUNILFNBL0NMO0FBaURILE9BakVNLENBQVA7QUFrRUg7QUFFRDs7Ozs7Ozs7bUNBS2VDLE8sRUFBUztBQUFBOztBQUNwQixVQUFNNkIsTUFBTSxDQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLEtBQWhCLEVBQXVCLE1BQXZCLEVBQStCLEVBQS9CLENBQVo7O0FBRUEsVUFBSTdCLFFBQVE4QixNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLFlBQUksS0FBSzVDLENBQUwsQ0FBT2lDLEtBQVAsQ0FBYUMsTUFBYixDQUFvQixLQUFLbEMsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2Qlcsb0JBQWpELENBQUosRUFBNEU7QUFDeEUsMkJBQU1jLEVBQU4sQ0FBUyxLQUFULEVBQWdCLEtBQUs3QyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCVyxvQkFBN0M7QUFDSDs7QUFDRCxvQkFBR2UsU0FBSCxDQUFhLEtBQUs5QyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCVyxvQkFBMUM7O0FBQ0Esb0JBQUdlLFNBQUgsQ0FBYSxLQUFLOUMsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QmUsdUJBQTFDOztBQUVBckIsZ0JBQVFlLE9BQVIsQ0FBZ0IsVUFBQ0csTUFBRCxFQUFZO0FBQ3hCLHNCQUFHZixVQUFILENBQ0ksY0FBS0ssSUFBTCxDQUFVLE9BQUt0QixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCRyxPQUF2QyxFQUFnRCxjQUFoRCxFQUFnRVMsTUFBaEUsQ0FESixFQUVJLGNBQUtWLElBQUwsQ0FBVSxPQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2Qlcsb0JBQXZDLEVBQTZEQyxNQUE3RCxDQUZKLEVBRHdCLENBS3hCOzs7QUFDQSxpQkFBS2UsVUFBTCxDQUFnQmYsTUFBaEIsRUFBd0JXLEdBQXhCO0FBQ0gsU0FQRDtBQVNBLGVBQU8sSUFBUDtBQUNIOztBQUNELGFBQU8sS0FBUDtBQUNIO0FBRUQ7Ozs7Ozs7OzsrQkFNV1gsTSxFQUFRVyxHLEVBQUs7QUFBQTs7QUFDcEIsVUFBSXBDLFdBQUo7O0FBQ0EsVUFBSTtBQUNBQSxzQkFBY3lDLEtBQUtDLEtBQUwsQ0FDVixZQUFHQyxZQUFILENBQ0ksY0FBSzVCLElBQUwsQ0FDSSxLQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2Qlcsb0JBRGpDLEVBQ3VEQyxNQUR2RCxFQUMrRCxjQUQvRCxDQURKLEVBSUksTUFKSixDQURVLENBQWQ7QUFRSCxPQVRELENBU0UsT0FBT21CLENBQVAsRUFBVTtBQUNSNUMsc0JBQWMsRUFBZDtBQUNIOztBQUdELFVBQU02QyxPQUFRLFNBQVM3QyxXQUFULElBQXdCLE9BQU9BLFlBQVk4QyxHQUFuQixLQUEyQixRQUFwRCxHQUFnRUMsT0FBT0MsSUFBUCxDQUFZaEQsWUFBWThDLEdBQXhCLENBQWhFLEdBQStGLEVBQTVHOztBQUVBLFVBQUlELEtBQUtSLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNqQlEsYUFBS3ZCLE9BQUwsQ0FBYSxVQUFDd0IsR0FBRCxFQUFTO0FBQ2xCVixjQUFJZCxPQUFKLENBQVksVUFBQzJCLFNBQUQsRUFBZTtBQUN2QixnQkFBTUMsY0FBYyxjQUFLbkMsSUFBTCxDQUNoQixPQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QkcsT0FEYixFQUVoQixjQUZnQixFQUdoQixNQUhnQixFQUlmLEdBQUU4QixHQUFJLEdBQUVHLFNBQVUsRUFKSCxDQUFwQjs7QUFNQSxnQkFBSSxPQUFLeEQsQ0FBTCxDQUFPaUMsS0FBUCxDQUFhQyxNQUFiLENBQW9CdUIsV0FBcEIsS0FDQSxPQUFLekQsQ0FBTCxDQUFPaUMsS0FBUCxDQUFheUIsYUFBYixDQUEyQkQsV0FBM0IsQ0FESixFQUVFO0FBQ0UsMEJBQUd4QyxVQUFILENBQ0l3QyxXQURKLEVBRUksY0FBS25DLElBQUwsQ0FDSSxPQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QmUsdUJBRGpDLEVBRUssR0FBRWtCLEdBQUksR0FBRUcsU0FBVSxFQUZ2QixDQUZKO0FBUUg7QUFDSixXQW5CRDtBQW9CSCxTQXJCRDtBQXNCSDtBQUNKO0FBRUQ7Ozs7OzswQ0FHc0I7QUFDbEIsVUFBTUcsd0JBQ0YsbUNBQXlCLEtBQUszRCxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCQyxXQUF0RCxDQURKO0FBRUEsVUFBTXVDLGdCQUFnQkQsc0JBQXNCRSxNQUF0QixFQUF0Qjs7QUFIa0Isa0NBS0EsS0FBSzdELENBQUwsQ0FBTzhELE9BQVAsQ0FBZUMsV0FBZixFQUxBO0FBQUEsVUFLWmpELE9BTFkseUJBS1pBLE9BTFk7O0FBT2xCLFVBQUksQ0FBQ2tELE1BQU1DLE9BQU4sQ0FBY25ELE9BQWQsQ0FBTCxFQUE2QjtBQUN6QkEsa0JBQVUsRUFBVjtBQUNIOztBQUVELFVBQU1vRCxRQUFRLEVBQWQ7QUFDQU4sb0JBQWN2QixNQUFkLENBQXFCdkIsT0FBckIsRUFBOEJlLE9BQTlCLENBQXNDLGtCQUFVO0FBQzVDcUMsY0FBTWxDLE1BQU4sSUFBZ0IsSUFBaEI7QUFDSCxPQUZEO0FBR0FsQixnQkFBVXdDLE9BQU9DLElBQVAsQ0FBWVcsS0FBWixDQUFWOztBQUNBLFVBQUlwRCxRQUFROEIsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUNwQixhQUFLM0MsR0FBTCxDQUFTa0UsT0FBVCxDQUFrQix5Q0FBd0NyRCxRQUFRUSxJQUFSLENBQWEsSUFBYixDQUFtQixFQUE3RTtBQUNIOztBQUNELGFBQU9SLE9BQVA7QUFDSDtBQUVEOzs7Ozs7b0RBR2dDO0FBQzVCLFdBQUtiLEdBQUwsQ0FBU2tFLE9BQVQsQ0FBaUIsbUNBQWpCO0FBQ0EsVUFBTUMsV0FBVyxLQUFLcEUsQ0FBTCxDQUFPOEQsT0FBUCxDQUFlQyxXQUFmLEVBQWpCOztBQUVBLFVBQUssb0NBQW9DSyxRQUF6QyxFQUFvRDtBQUNoRCxhQUFLM0Qsb0JBQUwsR0FBNkIsR0FBRTJELFNBQVNDLDhCQUErQixFQUF2RTtBQUNBLGFBQUtwRSxHQUFMLENBQVNxRSxJQUFULENBQWUsdUNBQXNDLEtBQUs3RCxvQkFBcUIsRUFBL0U7QUFDQTtBQUNIOztBQUVELFVBQU04RCxNQUFNLGdCQUFPQyxVQUFQLENBQWtCLEtBQWxCLENBQVo7O0FBQ0EsVUFBSW5FLGVBQWUsS0FBS0YsV0FBTCxDQUFpQnNFLGVBQWpCLEVBQW5CO0FBQ0EsVUFBTUMscUJBQXFCcEIsT0FBT0MsSUFBUCxDQUFZbEQsWUFBWixFQUEwQnNFLElBQTFCLEVBQTNCO0FBQ0F0RSxxQkFBZXFFLG1CQUFtQmpDLEdBQW5CLENBQXVCO0FBQUEsZUFDakMsR0FBRW1DLFVBQVcsSUFBR3ZFLGFBQWF1RSxVQUFiLENBQXlCLEVBRFI7QUFBQSxPQUF2QixDQUFmO0FBRUEsVUFBTUMsMkJBQTJCLEtBQUs3RSxDQUFMLENBQU84RSxVQUFQLEdBQW9CQyxLQUFwQixDQUEwQixHQUExQixDQUFqQztBQUNBLFdBQUs5RSxHQUFMLENBQVNlLEtBQVQsQ0FBZSwwQ0FBZixFQUNLLEdBQUU2RCx5QkFBeUIsQ0FBekIsQ0FBNEIsSUFBR0EseUJBQXlCLENBQXpCLENBQTRCLEVBRGxFO0FBRUF4RSxtQkFBYTJFLElBQWIsQ0FDSyxrQkFBaUJILHlCQUF5QixDQUF6QixDQUE0QixJQUFHQSx5QkFBeUIsQ0FBekIsQ0FBNEIsRUFEakY7QUFJQSxVQUFNSSw4QkFBOEJiLFNBQVM1RCxPQUFULENBQWlCdUUsS0FBakIsQ0FBdUIsR0FBdkIsRUFBNEIsQ0FBNUIsQ0FBcEM7QUFDQSxXQUFLOUUsR0FBTCxDQUFTZSxLQUFULENBQWUsb0NBQWYsRUFBcURpRSwyQkFBckQ7QUFDQTVFLG1CQUFhMkUsSUFBYixDQUNLLGVBQWNDLDJCQUE0QixFQUQvQzs7QUFJQSxVQUFJQyxRQUFRaEUsR0FBUixDQUFZaUUsa0RBQVosSUFDQUQsUUFBUWhFLEdBQVIsQ0FBWWtFLG9CQURoQixFQUVFO0FBQ0UsYUFBS25GLEdBQUwsQ0FBU2UsS0FBVCxDQUFnQix5Q0FBd0NnQyxLQUFLcUMsU0FBTCxDQUFlaEYsWUFBZixDQUE2QixFQUFyRjtBQUNIOztBQUVEa0UsVUFBSWUsTUFBSixDQUFXdEMsS0FBS3FDLFNBQUwsQ0FBZWhGLFlBQWYsQ0FBWDtBQUVBLFdBQUtJLG9CQUFMLEdBQTRCOEQsSUFBSWdCLE1BQUosQ0FBVyxLQUFYLENBQTVCO0FBQ0g7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHWUMsbUIsMkRBQU0sSztBQUNkO0FBQ0EscUJBQUt2RixHQUFMLENBQVNVLElBQVQsQ0FBYyxhQUFkOztBQUVBLG9CQUFJLENBQUMsS0FBS1gsQ0FBTCxDQUFPOEQsT0FBUCxDQUFlMkIsS0FBZixFQUFMLEVBQTZCO0FBQ3pCLHNCQUFJLENBQUMsS0FBS3pGLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV3dFLE9BQVgsQ0FBbUJ4RixRQUF4QixFQUFrQztBQUM5Qix5QkFBS0QsR0FBTCxDQUFTMEYsS0FBVCxDQUFlLHVFQUNYLCtEQURKLEVBRDhCLENBRzlCOztBQUNBVCw0QkFBUVUsSUFBUixDQUFhLENBQWI7QUFDSCxtQkFMRCxNQUtPO0FBQ0gseUJBQUs1RixDQUFMLENBQU84RCxPQUFQLENBQWU1RCxRQUFmO0FBQ0EseUJBQUtGLENBQUwsQ0FBT00sU0FBUCxDQUFpQnVGLGVBQWpCO0FBQ0g7QUFDSjs7QUFFRCxvQkFBSTtBQUNBLHVCQUFLN0YsQ0FBTCxDQUFPTSxTQUFQLENBQWlCdUYsZUFBakI7QUFDSCxpQkFGRCxDQUVFLE9BQU8xQyxDQUFQLEVBQVU7QUFDUix1QkFBS2xELEdBQUwsQ0FBU3FFLElBQVQsQ0FBZSwrQkFBOEIsS0FBS3RFLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkIwRSxRQUFTLEVBQXJFLEdBQ1YsaUJBREosRUFDdUIzQyxDQUR2QjtBQUVIOzs7O3VCQUdTLEtBQUtuRCxDQUFMLENBQU9NLFNBQVAsQ0FBaUJ5Rix3QkFBakIsRTs7Ozs7Ozs7O0FBRU4scUJBQUs5RixHQUFMLENBQVMwRixLQUFULENBQWUsOENBQWY7QUFDQVQsd0JBQVFVLElBQVIsQ0FBYSxDQUFiOzs7Ozt1QkFJTSxLQUFLMUYsUUFBTCxDQUFjOEYsSUFBZCxFOzs7Ozs7Ozs7QUFFTixxQkFBSy9GLEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSwyQkFBZjtBQUNBVCx3QkFBUVUsSUFBUixDQUFhLENBQWI7OztBQUdKLG9CQUFJO0FBQ0EsdUJBQUtLLHVCQUFMO0FBQ0gsaUJBRkQsQ0FFRSxPQUFPOUMsQ0FBUCxFQUFVO0FBQ1IsdUJBQUtsRCxHQUFMLENBQVMwRixLQUFULENBQWUscUNBQWYsRUFBc0R4QyxDQUF0RDtBQUNIOztBQUVELG9CQUFJO0FBQ0EsdUJBQUsrQyxzQkFBTDtBQUNILGlCQUZELENBRUUsT0FBTy9DLENBQVAsRUFBVTtBQUNSLHVCQUFLbEQsR0FBTCxDQUFTMEYsS0FBVCxDQUFlLHlDQUFmLEVBQTBEeEMsQ0FBMUQ7QUFDSDs7QUFFRCxvQkFBSTtBQUNBLHVCQUFLZ0QsNkJBQUw7QUFDSCxpQkFGRCxDQUVFLE9BQU9oRCxDQUFQLEVBQVU7QUFDUix1QkFBS2xELEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSxpREFBZixFQUFrRXhDLENBQWxFO0FBQ0ErQiwwQkFBUVUsSUFBUixDQUFhLENBQWI7QUFDSDs7Ozt1QkFHUyxLQUFLUSwwQkFBTCxFOzs7Ozs7Ozs7QUFFTixxQkFBS25HLEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSx3REFBZjtBQUNBVCx3QkFBUVUsSUFBUixDQUFhLENBQWI7Ozs7O3VCQUsyQixLQUFLUyx3QkFBTCxFOzs7QUFBM0JDLGtDOzs7Ozs7O0FBRUEscUJBQUtyRyxHQUFMLENBQVMwRixLQUFULENBQWUsOENBQWY7QUFDQVQsd0JBQVFVLElBQVIsQ0FBYSxDQUFiOzs7Ozt1QkFJTSxLQUFLVyxlQUFMLEU7Ozs7Ozs7OztBQUVOLHFCQUFLdEcsR0FBTCxDQUFTMEYsS0FBVCxDQUFnQiw0QkFBRCxXQUE4QixFQUE3QztBQUNBVCx3QkFBUVUsSUFBUixDQUFhLENBQWI7Ozs7O3VCQUlNLEtBQUtZLFdBQUwsQ0FBaUIsSUFBakIsQzs7Ozs7Ozs7O0FBRU4scUJBQUt2RyxHQUFMLENBQVMwRixLQUFULENBQWUsZ0RBQWY7QUFDQVQsd0JBQVFVLElBQVIsQ0FBYSxDQUFiOzs7b0JBR0NVLGtCOzs7Ozs7O3VCQUVTLEtBQUtFLFdBQUwsRTs7Ozs7Ozs7O0FBRU4scUJBQUt2RyxHQUFMLENBQVMwRixLQUFULENBQWUsdURBQWY7QUFDQVQsd0JBQVFVLElBQVIsQ0FBYSxDQUFiOzs7Ozt1QkFLRSxLQUFLYSx1QkFBTCxFOzs7Ozs7Ozs7QUFFTixxQkFBS3hHLEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSxzREFBZjtBQUNBVCx3QkFBUVUsSUFBUixDQUFhLENBQWI7Ozs7O3VCQUtNLEtBQUtjLHdCQUFMLEU7Ozs7Ozs7OztBQUVOLHFCQUFLekcsR0FBTCxDQUFTMEYsS0FBVCxDQUFlLG1FQUFmO0FBQ0FULHdCQUFRVSxJQUFSLENBQWEsQ0FBYjs7O3FCQUlBLEtBQUs1RixDQUFMLENBQU9rQixHQUFQLENBQVd5RixpQkFBWCxFOzs7Ozs7O3VCQUVVLEtBQUtDLGtCQUFMLEU7Ozs7Ozs7OztBQUVOLHFCQUFLM0csR0FBTCxDQUFTMEYsS0FBVCxDQUFlLHdDQUFmO0FBQ0FULHdCQUFRVSxJQUFSLENBQWEsQ0FBYjs7O0FBSVI7QUFDQSxvQkFBSTtBQUNBLHVCQUFLaUIsd0JBQUw7QUFDSCxpQkFGRCxDQUVFLE9BQU8xRCxDQUFQLEVBQVU7QUFDUix1QkFBS2xELEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSx3REFBZixFQUF5RXhDLENBQXpFO0FBQ0ErQiwwQkFBUVUsSUFBUixDQUFhLENBQWI7QUFDSDs7QUFFRCxvQkFBSTtBQUNBLHVCQUFLa0Isd0JBQUw7QUFDSCxpQkFGRCxDQUVFLE9BQU8zRCxDQUFQLEVBQVU7QUFDUix1QkFBS2xELEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSxzQ0FBZixFQUF1RHhDLENBQXZEO0FBQ0ErQiwwQkFBUVUsSUFBUixDQUFhLENBQWI7QUFDSDs7Ozt1QkFHUyxLQUFLbUIsdUJBQUwsRTs7Ozs7Ozs7O0FBRU4scUJBQUs5RyxHQUFMLENBQVMwRixLQUFULENBQWUsb0RBQWY7QUFDQVQsd0JBQVFVLElBQVIsQ0FBYSxDQUFiOzs7QUFHSixvQkFBSTtBQUNBLHVCQUFLb0Isa0JBQUw7QUFDSCxpQkFGRCxDQUVFLE9BQU83RCxDQUFQLEVBQVU7QUFDUix1QkFBS2xELEdBQUwsQ0FBUzBGLEtBQVQsQ0FBZSx3Q0FBZixFQUF5RHhDLENBQXpEO0FBQ0g7Ozs7dUJBR1MsS0FBSzhELGlCQUFMLEU7Ozs7Ozs7OztBQUVOLHFCQUFLaEgsR0FBTCxDQUFTMEYsS0FBVCxDQUFlLGlEQUFmO0FBQ0FULHdCQUFRVSxJQUFSLENBQWEsQ0FBYjs7Ozs7dUJBSU0sS0FBS3NCLG9CQUFMLEU7Ozs7Ozs7OztBQUVOLHFCQUFLakgsR0FBTCxDQUFTMEYsS0FBVCxDQUFlLHFEQUFmOzs7QUFHSixvQkFBSUgsR0FBSixFQUFTO0FBQ0wsdUJBQUt2RixHQUFMLENBQVNVLElBQVQsQ0FBYyxTQUFkO0FBQ0EsdUJBQUtYLENBQUwsQ0FBT21ILFFBQVAsQ0FBZ0IzQixHQUFoQjtBQUNILGlCQUhELE1BR087QUFDSCx1QkFBS3ZGLEdBQUwsQ0FBU1UsSUFBVCxDQUFjLE9BQWQ7QUFDSDs7Ozs7Ozs7Ozs7Ozs7QUFHTDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS1V5Ryx3QixHQUFXLEU7QUFDWEMsbUMsR0FBc0IsRTtBQUN4QkMsdUIsR0FBVSxXO0FBRWRoRSx1QkFBT0MsSUFBUCxDQUFZLEtBQUt2RCxDQUFMLENBQU84RCxPQUFQLENBQWVXLGVBQWYsR0FBaUM2QyxPQUE3QyxFQUFzRHpGLE9BQXRELENBQThELFVBQUMwRixNQUFELEVBQVk7QUFDdEU7QUFDQSxzQkFBTWhILGNBQ0Z5QyxLQUFLQyxLQUFMLENBQ0ksWUFBR0MsWUFBSCxDQUNJLGNBQUs1QixJQUFMLENBQ0ksT0FBS3RCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJDLFdBRGpDLEVBQzhDa0csTUFEOUMsRUFDc0QsY0FEdEQsQ0FESixFQUlJLE1BSkosQ0FESixDQURKOztBQVVBLHNCQUFJLHdCQUF3QmhILFdBQXhCLElBQXVDLE9BQU9BLFlBQVlpSCxrQkFBbkIsS0FBMEMsUUFBckYsRUFBK0Y7QUFDM0ZGLCtCQUFZLEdBQUVDLE1BQU8sSUFBckI7QUFDQUgsNkJBQVNLLE9BQVQsb0NBQW9CbkUsT0FBT0MsSUFBUCxDQUFZaEQsWUFBWWlILGtCQUF4QixDQUFwQjtBQUNBSCx3Q0FBb0JJLE9BQXBCLCtDQUErQkwsU0FBUzNFLEdBQVQsQ0FBYSxVQUFDaUYsV0FBRCxFQUFpQjtBQUN6RCwwQkFBSW5ILFlBQVlpSCxrQkFBWixDQUErQkUsV0FBL0IsTUFBZ0QsVUFBcEQsRUFBZ0U7QUFDNUQsK0JBQVEsR0FBRUEsV0FBWSxJQUFHbkgsWUFBWUMsT0FBUSxFQUE3QztBQUNIOztBQUNELDZCQUFRLEdBQUVrSCxXQUFZLElBQUduSCxZQUFZaUgsa0JBQVosQ0FBK0JFLFdBQS9CLENBQTRDLEVBQXJFO0FBQ0gscUJBTDhCLENBQS9CO0FBTUg7QUFDSixpQkF0QkQ7O3NCQXdCSU4sU0FBU3hFLE1BQVQsR0FBa0IsQzs7Ozs7QUFDbEIwRSwwQkFBVyxHQUFFQSxRQUFRSyxNQUFSLENBQWUsQ0FBZixFQUFrQkwsUUFBUTFFLE1BQVIsR0FBaUIsQ0FBbkMsQ0FBc0MsR0FBbkQ7Ozt1QkFFVSxLQUFLNUMsQ0FBTCxDQUFPTSxTQUFQLENBQWlCc0gsYUFBakIsQ0FBK0JDLGNBQS9CLENBQ0ZULFFBREUsRUFDUUMsbUJBRFIsRUFDNkJDLE9BRDdCLEM7Ozs7Ozs7OztzQkFJQSxJQUFJUSxLQUFKLGM7Ozs7Ozs7Ozs7Ozs7O0FBS2xCOzs7Ozs7Ozs7Ozs7Ozs7dUJBSVUsS0FBSzlILENBQUwsQ0FBT00sU0FBUCxDQUFpQnlILEtBQWpCLEU7Ozs7Ozs7Ozs7Ozs7O0FBR1Y7Ozs7Ozs7Ozs7Ozs7OztzQkFLUSxLQUFLL0gsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXeUYsaUJBQVgsTUFBa0MsS0FBSzNHLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV3dFLE9BQVgsQ0FBbUJzQyxJOzs7OztBQUNyRCxvQkFBSSxDQUFDLEtBQUtoSSxDQUFMLENBQU9rQixHQUFQLENBQVd5RixpQkFBWCxFQUFMLEVBQXFDO0FBQ2pDLHVCQUFLMUcsR0FBTCxDQUFTVSxJQUFULENBQWMseUVBQWQ7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsdUJBQUtWLEdBQUwsQ0FBU1UsSUFBVCxDQUFjLDBEQUFkO0FBQ0g7Ozs7dUJBRVMsS0FBS1gsQ0FBTCxDQUFPaUMsS0FBUCxDQUFhZ0csYUFBYixDQUNGLEtBREUsRUFDSyxLQUFLakksQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QkMsV0FEbEMsQzs7Ozs7Ozs7O3NCQUlBLElBQUl5RyxLQUFKLGM7OztrREFFSCxJOzs7a0RBRUosSzs7Ozs7Ozs7Ozs7Ozs7QUFHWDs7Ozs7Ozs7Ozs7Ozs7OztxQkFNUSxLQUFLOUgsQ0FBTCxDQUFPaUMsS0FBUCxDQUFhQyxNQUFiLENBQW9CLEtBQUtsQyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCOEcsY0FBakQsQzs7Ozs7b0JBQ0ssS0FBS2xJLENBQUwsQ0FBT2lDLEtBQVAsQ0FBYUMsTUFBYixDQUFvQixLQUFLbEMsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QkMsV0FBakQsQzs7Ozs7QUFDRCxxQkFBS3BCLEdBQUwsQ0FBU2UsS0FBVCxDQUFlLCtCQUFmOztBQUNBLGlDQUFNWSxFQUFOLENBQ0ksS0FBSzVCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkI4RyxjQURqQyxFQUVJLEtBQUtsSSxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCQyxXQUZqQzs7Ozs7O0FBS0E7QUFDQSxxQkFBS3BCLEdBQUwsQ0FBU2UsS0FBVCxDQUFlLCtEQUFmOzs7dUJBRVUsS0FBS2hCLENBQUwsQ0FBT2lDLEtBQVAsQ0FBYWdHLGFBQWIsQ0FDRixLQURFLEVBQ0ssS0FBS2pJLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkI4RyxjQURsQyxDOzs7Ozs7Ozs7c0JBSUEsSUFBSUosS0FBSixjOzs7Ozs7Ozs7Ozs7OztBQU10Qjs7Ozs7Ozs7Ozs7MkJBUU9LLFEsRUFBNEI7QUFBQTs7QUFBQSxVQUFsQkMsS0FBa0IsdUVBQVYsUUFBVTtBQUMvQixhQUFPLElBQUl4SCxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVd0gsTUFBVixFQUFxQjtBQUNwQztBQUNBLFlBQUlDLE1BQU0sY0FBS2hILElBQUwsQ0FDTixPQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCYixTQUFqQixDQUEyQmlDLElBRHJCLEVBQzJCLGNBRDNCLEVBQzJDLE1BRDNDLEVBQ21ELEtBRG5ELENBQVY7O0FBSUEsWUFBSSxDQUFDLE9BQUt2QyxDQUFMLENBQU9pQyxLQUFQLENBQWFDLE1BQWIsQ0FBb0JvRyxHQUFwQixDQUFMLEVBQStCO0FBQzNCQSxnQkFBTSxjQUFLaEgsSUFBTCxDQUNGLE9BQUt0QixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJiLFNBQWpCLENBQTJCaUMsSUFEekIsRUFDK0IsY0FEL0IsRUFDK0MsZ0JBRC9DLEVBQ2lFLGNBRGpFLEVBQ2lGLE1BRGpGLEVBQ3lGLEtBRHpGLENBQU47QUFHSDs7QUFFRCxZQUFJLENBQUMsT0FBS3ZDLENBQUwsQ0FBT2lDLEtBQVAsQ0FBYUMsTUFBYixDQUFvQm9HLEdBQXBCLENBQUwsRUFBK0I7QUFDM0JBLGdCQUFNLGlCQUFNQyxLQUFOLENBQVksS0FBWixDQUFOO0FBQ0g7O0FBRUQsZUFBS3RJLEdBQUwsQ0FBU2tFLE9BQVQsQ0FBa0IsaUJBQWdCZ0UsU0FBUzdHLElBQVQsQ0FBYyxHQUFkLENBQW1CLEVBQXJEOztBQUVBLGlDQUFNZ0gsR0FBTixFQUFXSCxRQUFYLEVBQXFCO0FBQ2pCSyxlQUFLLE9BQUt4SSxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCbUIsSUFEakI7QUFFakI2RjtBQUZpQixTQUFyQixFQUdHSyxFQUhILENBR00sTUFITixFQUdjO0FBQUEsaUJBQ1RDLFNBQVMsQ0FBVixHQUFlN0gsU0FBZixHQUEyQndILE9BQU8sSUFBSVAsS0FBSixDQUFXLHFCQUFvQlksSUFBSyxFQUFwQyxDQUFQLENBRGpCO0FBQUEsU0FIZDtBQU1ILE9BeEJNLENBQVA7QUF5Qkg7QUFHRDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJVXRFLHdCLEdBQVcsS0FBS3BFLENBQUwsQ0FBTzhELE9BQVAsQ0FBZUMsV0FBZixFO0FBQ1g0RSx3QixHQUFXLEU7O0FBQ2pCLG9CQUFJLGtCQUFrQixLQUFLM0ksQ0FBTCxDQUFPOEQsT0FBUCxDQUFlQyxXQUFmLEVBQXRCLEVBQW9EO0FBQ2hELHNCQUFJQyxNQUFNQyxPQUFOLENBQWNHLFNBQVN3RSxZQUF2QixDQUFKLEVBQTBDO0FBQ3RDeEUsNkJBQVN3RSxZQUFULENBQXNCL0csT0FBdEIsQ0FBOEI7QUFBQSw2QkFDMUI4RyxTQUFTM0QsSUFBVCxDQUFjLE9BQUs2RCxNQUFMLENBQVksQ0FBQyxNQUFELEVBQVNuQixXQUFULENBQVosQ0FBZCxDQUQwQjtBQUFBLHFCQUE5QjtBQUVIO0FBQ0o7Ozt1QkFDSzlHLFFBQVFrSSxHQUFSLENBQVlILFFBQVosQzs7Ozs7Ozs7Ozs7Ozs7QUFHVjs7Ozs7Ozs7Ozs7Ozs7O0FBS0kscUJBQUsxSSxHQUFMLENBQVNVLElBQVQsQ0FBYyx5QkFBZDs7cUJBQ0ksS0FBS1gsQ0FBTCxDQUFPaUMsS0FBUCxDQUFhQyxNQUFiLENBQW9CLEtBQUtsQyxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCQyxXQUFqRCxDOzs7OztBQUNBLHFCQUFLcEIsR0FBTCxDQUFTZSxLQUFULENBQWUsaURBQWY7Ozt1QkFFVSxLQUFLNkgsTUFBTCxDQUFZLENBQUMsT0FBRCxDQUFaLEM7Ozs7Ozs7OztzQkFFQSxJQUFJZixLQUFKLGM7Ozs7O3VCQUlKLEtBQUtlLE1BQUwsQ0FBWSxDQUFDLFNBQUQsQ0FBWixFQUF5QixLQUFLN0ksQ0FBTCxDQUFPa0IsR0FBUCxDQUFXa0gsS0FBcEMsQzs7Ozs7Ozs7O3NCQUVBLElBQUlOLEtBQUosYzs7Ozs7Ozs7Ozs7Ozs7QUFJZDs7Ozs7Ozt3Q0FJb0JpQixlLEVBQWlCO0FBQUE7O0FBQ2pDLFVBQU1DLGVBQWVoRyxLQUFLQyxLQUFMLENBQ2pCLFlBQUdDLFlBQUgsQ0FBZ0IsY0FBSzVCLElBQUwsQ0FBVSxLQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCakIsUUFBM0IsRUFBcUMsZUFBckMsQ0FBaEIsQ0FEaUIsQ0FBckI7QUFHQSxVQUFNK0kseUJBQXlCLEtBQUtqSixDQUFMLENBQU84RCxPQUFQLENBQWVXLGVBQWYsQ0FBK0J1RSxZQUEvQixFQUE2QyxLQUE3QyxFQUFvRDFCLE9BQW5GO0FBQ0FoRSxhQUFPQyxJQUFQLENBQVl3RixlQUFaLEVBQTZCbEgsT0FBN0IsQ0FBcUMsVUFBQ3FILFVBQUQsRUFBZ0I7QUFDakQsWUFBSUEsY0FBY0Qsc0JBQWQsSUFDQUEsdUJBQXVCQyxVQUF2QixNQUF1Q0gsZ0JBQWdCRyxVQUFoQixDQUR2QyxJQUVBLGdCQUFPQyxFQUFQLENBQVVKLGdCQUFnQkcsVUFBaEIsQ0FBVixFQUF1Q0QsdUJBQXVCQyxVQUF2QixDQUF2QyxDQUZKLEVBR0U7QUFDRSxpQkFBS2pKLEdBQUwsQ0FBU3FFLElBQVQsQ0FBZSxrQ0FBaUN5RSxnQkFBZ0JHLFVBQWhCLENBQTRCLE1BQTlELEdBQ1QsR0FBRUEsVUFBVyxvQ0FESixHQUVULEdBQUVELHVCQUF1QkMsVUFBdkIsQ0FBbUMsRUFGMUM7QUFHSDtBQUNKLE9BVEQ7QUFVSDtBQUVEOzs7Ozs7NkNBR3lCO0FBQUE7O0FBQ3JCLFdBQUtqSixHQUFMLENBQVNVLElBQVQsQ0FBYywrQ0FBZDtBQUNBLFVBQU15SSxzQkFBc0IsS0FBS3BKLENBQUwsQ0FBTzhELE9BQVAsQ0FBZVcsZUFBZixFQUE1QjtBQUVBLFdBQUs0RSxtQkFBTCxDQUF5QkQsb0JBQW9COUIsT0FBN0M7QUFFQSxXQUFLckgsR0FBTCxDQUFTZSxLQUFULENBQWUscUNBQWY7QUFDQSxXQUFLYixXQUFMLENBQWlCbUosaUJBQWpCLENBQ0ksNkJBREosRUFFSUYsb0JBQW9CRyxZQUZ4QjtBQUlBLFdBQUt0SixHQUFMLENBQVNlLEtBQVQsQ0FBZSxnQ0FBZjtBQUNBLFdBQUtiLFdBQUwsQ0FBaUJtSixpQkFBakIsQ0FDSSx3QkFESixFQUVJRixvQkFBb0I5QixPQUZ4QjtBQUtBLFdBQUtySCxHQUFMLENBQVNlLEtBQVQsQ0FBZSxtQ0FBZjtBQUNBc0MsYUFBT0MsSUFBUCxDQUFZNkYsb0JBQW9CSSxPQUFoQyxFQUF5QzNILE9BQXpDLENBQWlEO0FBQUEsZUFDN0MsT0FBSzFCLFdBQUwsQ0FBaUJtSixpQkFBakIsQ0FDSyxVQUFTdEgsTUFBTyxHQURyQixFQUVJb0gsb0JBQW9CSSxPQUFwQixDQUE0QnhILE1BQTVCLENBRkosQ0FENkM7QUFBQSxPQUFqRDtBQU1BLFdBQUt6QixXQUFMLENBQWlCRixZQUFqQixHQUFnQyxLQUFLRixXQUFMLENBQWlCc0oscUJBQWpCLEVBQWhDO0FBQ0EsV0FBS2xKLFdBQUwsQ0FBaUJtSixpQkFBakIsR0FBcUMsS0FBS3ZKLFdBQUwsQ0FBaUJ3SixvQkFBakIsRUFBckM7QUFFQSxXQUFLMUosR0FBTCxDQUFTZSxLQUFULENBQWUsOEJBQWY7O0FBQ0Esa0JBQUc0SSxhQUFILENBQ0ksS0FBSzVKLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJiLFdBRGpDLEVBQzhDeUMsS0FBS3FDLFNBQUwsQ0FBZSxLQUFLOUUsV0FBcEIsRUFBaUMsSUFBakMsRUFBdUMsQ0FBdkMsQ0FEOUM7QUFHSDtBQUVEOzs7Ozs7Ozs7OENBTW9HO0FBQUEsVUFBNUVzSixJQUE0RSx1RUFBckUsS0FBSzdKLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV3dFLE9BQVgsQ0FBbUJzQyxJQUFuQixJQUEyQjlDLFFBQVEyRSxJQUFSLEtBQWlCLE1BQTVDLEdBQXFELE1BQXJELEdBQThELEtBQU87O0FBQ2hHLFVBQU1ILG9CQUFvQixnQkFBRUksTUFBRixDQUFTLEtBQUt2SixXQUFMLENBQWlCbUosaUJBQTFCLENBQTFCOztBQUNBLFVBQUlBLGtCQUFrQjlHLE1BQWxCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ2hDLGVBQU9oQyxRQUFRQyxPQUFSLEVBQVA7QUFDSDs7QUFDRCxXQUFLWixHQUFMLENBQVNVLElBQVQsQ0FBYywrQkFBZDtBQUNBLFVBQU1vSixjQUFjLEtBQUsvSixDQUFMLENBQU9nSyxlQUFQLENBQXVCQyx3QkFBdkIsQ0FBZ0RKLElBQWhELENBQXBCO0FBQ0EsVUFBTTNJLE1BQU0scUJBQVU2SSxZQUFZRyxhQUF0QixFQUFxQ0gsWUFBWUksUUFBakQsRUFBMkRKLFlBQVlGLElBQXZFLENBQVo7QUFDQSxVQUFNTyxZQUFZLGlDQUNkO0FBQUUsU0FBQyxLQUFLcEssQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2Qm1CLElBQTlCLEdBQXFDbUg7QUFBdkMsT0FEYyxFQUVkO0FBQUVXLGdCQUFRbko7QUFBVixPQUZjLENBQWxCO0FBSUEsa0NBQVNrSixTQUFUO0FBQ0EsYUFBT0EsVUFBVUUsT0FBVixFQUFQO0FBQ0g7QUFFRDs7Ozs7OztrQ0FJNkI7QUFBQSxVQUFqQkEsT0FBaUIsdUVBQVAsS0FBTzs7QUFDekIsVUFBSUEsT0FBSixFQUFhO0FBQ1QsYUFBS3JLLEdBQUwsQ0FBU1UsSUFBVCxDQUFjLG9EQUFkO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsYUFBS1YsR0FBTCxDQUFTVSxJQUFULENBQWMsc0RBQWQ7QUFDSDs7QUFFRCxVQUFNa0osT0FBTyxLQUFLN0osQ0FBTCxDQUFPa0IsR0FBUCxDQUFXd0UsT0FBWCxDQUFtQnNDLElBQW5CLElBQTJCOUMsUUFBUTJFLElBQVIsS0FBaUIsTUFBNUMsR0FBcUQsTUFBckQsR0FBOEQsS0FBM0U7O0FBRUEsVUFBSSxLQUFLN0osQ0FBTCxDQUFPa0IsR0FBUCxDQUFXd0UsT0FBWCxDQUFtQnNDLElBQXZCLEVBQTZCO0FBQ3pCLGFBQUsvSCxHQUFMLENBQVNrRSxPQUFULENBQWlCLDJCQUFqQjtBQUNILE9BRkQsTUFFTztBQUNILGFBQUtsRSxHQUFMLENBQVNrRSxPQUFULENBQWtCLGtCQUFpQjBGLElBQUssRUFBeEM7QUFDSDs7QUFFRCxhQUFPLEtBQUs3SixDQUFMLENBQU9nSyxlQUFQLENBQXVCTyxnQkFBdkIsQ0FBd0NWLElBQXhDLEVBQThDVyxTQUE5QyxFQUF5REYsT0FBekQsQ0FBUDtBQUNIO0FBRUQ7Ozs7Ozs7Ozs7OENBTzBCO0FBQ3RCLFdBQUtySyxHQUFMLENBQVNrRSxPQUFULENBQWlCLDhCQUFqQjtBQUNBLFVBQU1DLFdBQVcsS0FBS3BFLENBQUwsQ0FBTzhELE9BQVAsQ0FBZUMsV0FBZixFQUFqQjtBQUNBOztBQUNBLFVBQU14RCxjQUFjLEtBQUtMLFFBQUwsQ0FBY0UscUJBQWQsRUFBcEI7QUFFQUcsa0JBQVlDLE9BQVosR0FBc0I0RCxTQUFTNUQsT0FBL0I7O0FBQ0EsVUFBSSx1QkFBdUI0RCxRQUEzQixFQUFxQztBQUNqQywrQkFBUzdELFdBQVQsRUFBc0I2RCxTQUFTcUcsaUJBQS9CO0FBQ0g7O0FBQ0QsNkJBQVNsSyxXQUFULEVBQXNCO0FBQUVtSyxjQUFNdEcsU0FBU3VHO0FBQWpCLE9BQXRCO0FBRUEsV0FBSzFLLEdBQUwsQ0FBU2UsS0FBVCxDQUFlLDhCQUFmOztBQUNBLGtCQUFHNEksYUFBSCxDQUNJLEtBQUs1SixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUJDLFdBQWpCLENBQTZCYixXQURqQyxFQUM4Q3lDLEtBQUtxQyxTQUFMLENBQWU5RSxXQUFmLEVBQTRCLElBQTVCLEVBQWtDLENBQWxDLENBRDlDOztBQUdBLFdBQUtBLFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0g7QUFFRDs7Ozs7OytDQUcyQjtBQUN2QixXQUFLTixHQUFMLENBQVNlLEtBQVQsQ0FBZSwrQkFBZjtBQUNBLFVBQU1vRCxXQUFXLEtBQUtwRSxDQUFMLENBQU84RCxPQUFQLENBQWVDLFdBQWYsRUFBakIsQ0FGdUIsQ0FJdkI7O0FBQ0FLLGVBQVMzRCxvQkFBVCxHQUFnQyxLQUFLQSxvQkFBckMsQ0FMdUIsQ0FPdkI7O0FBQ0EyRCxlQUFTbEQsR0FBVCxHQUFnQixLQUFLbEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXeUYsaUJBQVgsRUFBRCxHQUNYLE1BRFcsR0FDRixLQURiO0FBR0F2QyxlQUFTd0csY0FBVCxHQUEyQixHQUFFLEtBQUs1SyxDQUFMLENBQU84RCxPQUFQLENBQWUrRyxjQUFmLEVBQWdDLElBQUd6RyxTQUFTbEQsR0FBSSxFQUE3RTtBQUVBa0QsZUFBUzBHLG9CQUFULEdBQWdDLEtBQUs5SyxDQUFMLENBQU84RSxVQUFQLEVBQWhDOztBQUVBLGtCQUFHOEUsYUFBSCxDQUNJLEtBQUs1SixDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUI0SixVQUFqQixDQUE0QjNHLFFBRGhDLEVBQzBDcEIsS0FBS3FDLFNBQUwsQ0FBZWpCLFFBQWYsRUFBeUIsSUFBekIsRUFBK0IsQ0FBL0IsQ0FEMUM7QUFHSDtBQUVEOzs7Ozs7d0NBR29CO0FBQUE7O0FBQ2hCLFdBQUtuRSxHQUFMLENBQVNVLElBQVQsQ0FBYywwQkFBZDtBQUNBLGFBQU8sSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVXdILE1BQVYsRUFBcUI7QUFDcEMsc0JBQUszRyxhQUFMLENBQ0ksT0FBSzFCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQjRKLFVBQWpCLENBQTRCeEksSUFEaEMsRUFFSSxPQUFLdkMsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QjRKLFdBRmpDLEVBR0ksWUFBTTtBQUNGLGlCQUFLL0ssR0FBTCxDQUFTa0UsT0FBVCxDQUFpQiw2QkFBakI7O0FBQ0EsaUJBQUtuRSxDQUFMLENBQU9pQyxLQUFQLENBQ0tnRyxhQURMLENBQ21CLEtBRG5CLEVBQzBCLE9BQUtqSSxDQUFMLENBQU9rQixHQUFQLENBQVdDLEtBQVgsQ0FBaUI0SixVQUFqQixDQUE0QnhJLElBRHRELEVBRUswSSxJQUZMLENBRVUsWUFBTTtBQUNScEs7QUFDSCxXQUpMLEVBS0txSyxLQUxMLENBS1csVUFBQy9ILENBQUQsRUFBTztBQUNWa0YsbUJBQU9sRixDQUFQO0FBQ0gsV0FQTDs7QUFRQXRDO0FBQ0gsU0FkTDtBQWdCSCxPQWpCTSxDQUFQO0FBa0JIO0FBRUQ7Ozs7OzsrQ0FHMkI7QUFDdkIsV0FBS1osR0FBTCxDQUFTa0UsT0FBVCxDQUFpQix3Q0FBakI7O0FBQ0EsdUJBQU1yQyxFQUFOLENBQVMsS0FBVCxFQUFnQixLQUFLOUIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCMkMsT0FBakIsQ0FBeUJ2QixJQUF6QyxFQUErQyxLQUFLdkMsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCNEosVUFBakIsQ0FBNEJ4SSxJQUEzRSxFQUZ1QixDQUd2Qjs7O0FBQ0EsbUJBQUlELElBQUosQ0FBUyxDQUNMLGNBQUtoQixJQUFMLENBQVUsS0FBS3RCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQjRKLFVBQWpCLENBQTRCeEksSUFBdEMsRUFBNEMsSUFBNUMsRUFBa0QsV0FBbEQsQ0FESyxDQUFUO0FBR0g7QUFHRDs7Ozs7O3lDQUdxQjtBQUNqQixXQUFLdEMsR0FBTCxDQUFTVSxJQUFULENBQWMsMkJBQWQ7QUFFQSxVQUFNeUQsV0FBVyxLQUFLcEUsQ0FBTCxDQUFPOEQsT0FBUCxDQUFlQyxXQUFmLEVBQWpCO0FBQ0EsVUFBTTJCLFVBQVUsbUJBQW1CdEIsUUFBbkIsR0FBOEJBLFNBQVMrRyxhQUF2QyxHQUF1RCxFQUF2RTtBQUVBLFVBQU1DLG1CQUFtQixZQUFZaEgsUUFBWixJQUF3QixDQUFDLENBQUNBLFNBQVNpSCxNQUE1RDtBQUVBLFVBQU1DLFNBQVMsd0JBQVVkLFNBQVYsRUFBcUI7QUFBRWUsaUJBQVM7QUFBRUMsZ0JBQU07QUFBUjtBQUFYLE9BQXJCLENBQWY7O0FBRUEsb0JBQUtsSixJQUFMLENBQVcsR0FBRSxLQUFLdEMsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCNEosVUFBakIsQ0FBNEJ4SSxJQUFLLFVBQTlDLEVBQXlEVixPQUF6RCxDQUFpRSxVQUFDNEosSUFBRCxFQUFVO0FBQUEsaUNBQ3hELDZCQUFrQkEsSUFBbEIsRUFBd0I7QUFDbkNDLG1CQUFTLENBQUNKLE1BQUQ7QUFEMEIsU0FBeEIsQ0FEd0Q7QUFBQSxZQUNqRTVDLElBRGlFLHNCQUNqRUEsSUFEaUU7O0FBSXZFLFlBQUkvQyxLQUFKOztBQUNBLFlBQUl2QixTQUFTbEQsR0FBVCxLQUFpQixNQUFqQixJQUEyQmtLLGdCQUEvQixFQUFpRDtBQUFBLCtCQUMxQixrQkFBT08sTUFBUCxDQUFjakQsSUFBZCxFQUFvQmhELE9BQXBCLENBRDBCOztBQUMxQ2dELGNBRDBDLGtCQUMxQ0EsSUFEMEM7QUFDcEMvQyxlQURvQyxrQkFDcENBLEtBRG9DO0FBRWhEOztBQUNELFlBQUlBLEtBQUosRUFBVztBQUNQLGdCQUFNLElBQUltQyxLQUFKLENBQVVuQyxLQUFWLENBQU47QUFDSDs7QUFDRCxvQkFBR2lFLGFBQUgsQ0FBaUI2QixJQUFqQixFQUF1Qi9DLElBQXZCO0FBQ0gsT0FaRDtBQWFIO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUtJLHFCQUFLekksR0FBTCxDQUFTVSxJQUFULENBQWMsOEJBQWQsRSxDQUVBOzs7O3VCQUdVLEtBQUtYLENBQUwsQ0FBT2lDLEtBQVAsQ0FBYWdHLGFBQWIsQ0FBMkIsS0FBM0IsRUFBa0MsS0FBS2pJLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJJLFNBQS9ELEM7Ozs7Ozs7OztzQkFFQSxJQUFJc0csS0FBSixjOzs7QUFHVixpQ0FBTThELEtBQU4sQ0FBWSxLQUFLNUwsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCQyxXQUFqQixDQUE2QkksU0FBekM7O0FBRU1xSyx1QixHQUFVLEtBQUs3TCxDQUFMLENBQU84RCxPQUFQLENBQWVnSSxtQkFBZixFLEVBRWhCOztBQUNBRCx3QkFBUWhLLE9BQVIsQ0FBZ0IsVUFBQ2hDLE1BQUQsRUFBWTtBQUN4QixzQkFBTWtNLGVBQWVsTSxNQUFyQjs7QUFDQSxzQkFBSSxhQUFha00sWUFBakIsRUFBK0I7QUFDM0Isd0JBQUksQ0FBQy9ILE1BQU1DLE9BQU4sQ0FBYzhILGFBQWFqTCxPQUEzQixDQUFMLEVBQTBDO0FBQ3RDaUwsbUNBQWFqTCxPQUFiLEdBQXVCLENBQUNpTCxhQUFhakwsT0FBZCxDQUF2QjtBQUNIOztBQUNEaUwsaUNBQWFqTCxPQUFiLENBQXFCZSxPQUFyQixDQUE2QixVQUFDNEosSUFBRCxFQUFVO0FBQ25DLDhCQUFLeEwsR0FBTCxDQUFTZSxLQUFULENBQWdCLGFBQVl5SyxJQUFLLFNBQVE1TCxPQUFPNkssSUFBSyxFQUFyRDs7QUFDQSwwQkFBTXNCLFdBQVcsY0FBSzFLLElBQUwsQ0FDYixRQUFLdEIsQ0FBTCxDQUFPa0IsR0FBUCxDQUFXQyxLQUFYLENBQWlCNEosVUFBakIsQ0FBNEJ2QixPQURmLEVBQ3dCdUMsYUFBYUUsT0FEckMsRUFDOENSLElBRDlDLENBQWpCOztBQUdBLDBCQUFNUyxrQkFBa0IsY0FBSzVLLElBQUwsQ0FDcEIsUUFBS3RCLENBQUwsQ0FBT2tCLEdBQVAsQ0FBV0MsS0FBWCxDQUFpQkMsV0FBakIsQ0FBNkJJLFNBRFQsRUFDb0J1SyxhQUFhRSxPQURqQyxDQUF4Qjs7QUFJQSwwQkFBSSxDQUFDLFFBQUtqTSxDQUFMLENBQU9pQyxLQUFQLENBQWFDLE1BQWIsQ0FBb0JnSyxlQUFwQixDQUFMLEVBQTJDO0FBQ3ZDLHlDQUFNTixLQUFOLENBQVlNLGVBQVo7QUFDSDs7QUFDRCx1Q0FBTXRLLEVBQU4sQ0FBU29LLFFBQVQsRUFBbUJFLGVBQW5CO0FBQ0gscUJBYkQ7QUFjSDtBQUNKLGlCQXJCRCIsImZpbGUiOiJlbGVjdHJvbkFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc2FyIGZyb20gJ2FzYXInO1xuaW1wb3J0IGFzc2lnbkluIGZyb20gJ2xvZGFzaC9hc3NpZ25Jbic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgTG9jYWxJbnN0YWxsZXIsIHByb2dyZXNzIH0gZnJvbSAnaW5zdGFsbC1sb2NhbCc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1GaWxlU3luYyB9IGZyb20gJ0BiYWJlbC9jb3JlJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCBkZWwgZnJvbSAnZGVsJztcbmltcG9ydCBwcmVzZXRFbnYgZnJvbSAnQGJhYmVsL3ByZXNldC1lbnYnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBnbG9iIGZyb20gJ2dsb2InO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2hlbGwgZnJvbSAnc2hlbGxqcyc7XG5pbXBvcnQgc3Bhd24gZnJvbSAnY3Jvc3Mtc3Bhd24nO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuaW1wb3J0IHVnbGlmeSBmcm9tICd1Z2xpZnktZXMnO1xuXG5pbXBvcnQgeyBnZXRHeXBFbnYgfSBmcm9tICdlbGVjdHJvbi1idWlsZGVyLWxpYi9vdXQvdXRpbC95YXJuJztcblxuaW1wb3J0IExvZyBmcm9tICcuL2xvZyc7XG5pbXBvcnQgRWxlY3Ryb25BcHBTY2FmZm9sZCBmcm9tICcuL2VsZWN0cm9uQXBwU2NhZmZvbGQnO1xuaW1wb3J0IERlcGVuZGVuY2llc01hbmFnZXIgZnJvbSAnLi9kZXBlbmRlbmNpZXNNYW5hZ2VyJztcbmltcG9ydCBCaW5hcnlNb2R1bGVEZXRlY3RvciBmcm9tICcuL2JpbmFyeU1vZHVsZXNEZXRlY3Rvcic7XG5cbnNoZWxsLmNvbmZpZy5mYXRhbCA9IHRydWU7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgLmRlc2t0b3AgZGlyIHNjYWZmb2xkLlxuICogQGNsYXNzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZWN0cm9uQXBwIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01ldGVvckRlc2t0b3B9ICQgLSBjb250ZXh0XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoJCkge1xuICAgICAgICB0aGlzLmxvZyA9IG5ldyBMb2coJ2VsZWN0cm9uQXBwJyk7XG4gICAgICAgIHRoaXMuc2NhZmZvbGQgPSBuZXcgRWxlY3Ryb25BcHBTY2FmZm9sZCgkKTtcbiAgICAgICAgdGhpcy5kZXBzTWFuYWdlciA9IG5ldyBEZXBlbmRlbmNpZXNNYW5hZ2VyKFxuICAgICAgICAgICAgJCxcbiAgICAgICAgICAgIHRoaXMuc2NhZmZvbGQuZ2V0RGVmYXVsdFBhY2thZ2VKc29uKCkuZGVwZW5kZW5jaWVzXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuJCA9ICQ7XG4gICAgICAgIHRoaXMubWV0ZW9yQXBwID0gdGhpcy4kLm1ldGVvckFwcDtcbiAgICAgICAgdGhpcy5wYWNrYWdlSnNvbiA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGF0aWJpbGl0eVZlcnNpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGFuIGFwcC5hc2FyIGZyb20gdGhlIHNrZWxldG9uIGFwcC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBleGNsdWRlRnJvbURlbCAtIGxpc3Qgb2YgcGF0aHMgdG8gZXhjbHVkZSBmcm9tIGRlbGV0aW5nXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgcGFja1NrZWxldG9uVG9Bc2FyKGV4Y2x1ZGVGcm9tRGVsID0gW10pIHtcbiAgICAgICAgdGhpcy5sb2cuaW5mbygncGFja2luZyBza2VsZXRvbiBhcHAgYW5kIG5vZGVfbW9kdWxlcyB0byBhc2FyIGFyY2hpdmUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHRyYWN0ID0gdGhpcy5nZXRNb2R1bGVzVG9FeHRyYWN0KCk7XG5cbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gcGFjayBza2VsZXRvbiBhcHAgYW5kIG5vZGVfbW9kdWxlcyB0b2dldGhlciwgc28gd2UgbmVlZCB0byB0ZW1wb3JhcmlseVxuICAgICAgICAgICAgLy8gbW92ZSBub2RlX21vZHVsZXMgdG8gYXBwIGRpci5cbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdtb3Zpbmcgbm9kZV9tb2R1bGVzIHRvIGFwcCBkaXInKTtcblxuICAgICAgICAgICAgZnMucmVuYW1lU3luYyhcbiAgICAgICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLm5vZGVNb2R1bGVzLFxuICAgICAgICAgICAgICAgIHBhdGguam9pbih0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmFwcFJvb3QsICdub2RlX21vZHVsZXMnKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGV4dHJhY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZXh0cmFjdGVkID0gdGhpcy5leHRyYWN0TW9kdWxlcyhleHRyYWN0KTtcblxuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3BhY2tpbmcnKTtcbiAgICAgICAgICAgIGFzYXIuY3JlYXRlUGFja2FnZShcbiAgICAgICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmFwcFJvb3QsXG4gICAgICAgICAgICAgICAgdGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5hcHBBc2FyLFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0cyBtb3ZlIHRoZSBub2RlX21vZHVsZXMgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ21vdmluZyBub2RlX21vZHVsZXMgYmFjayBmcm9tIGFwcCBkaXInKTtcblxuICAgICAgICAgICAgICAgICAgICBzaGVsbC5tdihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguam9pbih0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmFwcFJvb3QsICdub2RlX21vZHVsZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAubm9kZU1vZHVsZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhIGZ1bGwgbm9kZSBtb2R1bGVzIGJhY2suIEluIG90aGVyIHdvcmRzIHdlIHdhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBleHRyYWN0ZWQgbW9kdWxlcyBiYWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdC5mb3JFYWNoKG1vZHVsZSA9PiBzaGVsbC5jcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLXJmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4odGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlcywgbW9kdWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4odGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5ub2RlTW9kdWxlcywgbW9kdWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgLmJpbiBiYWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuJC51dGlscy5leGlzdHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlc0JpblxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWxsLmNwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4odGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlc0JpbiwgJyonKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAubm9kZU1vZHVsZXMsICcuYmluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2RlbGV0aW5nIHNvdXJjZSBmaWxlcycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlID0gW3RoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAubm9kZU1vZHVsZXNdLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmFwcEFzYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5wYWNrYWdlSnNvblxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVGcm9tRGVsXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsLnN5bmMoXG4gICAgICAgICAgICAgICAgICAgICAgICBbYCR7dGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5yb290fSR7cGF0aC5zZXB9KmBdLmNvbmNhdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNsdWRlLm1hcChwYXRoVG9FeGNsdWRlID0+IGAhJHtwYXRoVG9FeGNsdWRlfWApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBzcGVjaWZpZWQgbm9kZSBtb2R1bGVzIHRvIGEgc2VwYXJhdGUgZGlyZWN0b3J5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGV4dHJhY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBleHRyYWN0TW9kdWxlcyhleHRyYWN0KSB7XG4gICAgICAgIGNvbnN0IGV4dCA9IFsnLmpzJywgJy5iYXQnLCAnLnNoJywgJy5jbWQnLCAnJ107XG5cbiAgICAgICAgaWYgKGV4dHJhY3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuJC51dGlscy5leGlzdHModGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlcykpIHtcbiAgICAgICAgICAgICAgICBzaGVsbC5ybSgnLXJmJywgdGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcy5ta2RpclN5bmModGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlcyk7XG4gICAgICAgICAgICBmcy5ta2RpclN5bmModGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlc0Jpbik7XG5cbiAgICAgICAgICAgIGV4dHJhY3QuZm9yRWFjaCgobW9kdWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgZnMucmVuYW1lU3luYyhcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAuYXBwUm9vdCwgJ25vZGVfbW9kdWxlcycsIG1vZHVsZSksXG4gICAgICAgICAgICAgICAgICAgIHBhdGguam9pbih0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmV4dHJhY3RlZE5vZGVNb2R1bGVzLCBtb2R1bGUpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSBiaW5zLlxuICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFjdEJpbihtb2R1bGUsIGV4dCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBiaW4gZmlsZXMgYXNzb2NpYXRlZCB3aXRoIGEgY2VydGFpbiBub2RlIG1vZHVsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kdWxlXG4gICAgICogQHBhcmFtIGV4dFxuICAgICAqL1xuICAgIGV4dHJhY3RCaW4obW9kdWxlLCBleHQpIHtcbiAgICAgICAgbGV0IHBhY2thZ2VKc29uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFja2FnZUpzb24gPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlU3luYyhcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5qb2luKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5leHRyYWN0ZWROb2RlTW9kdWxlcywgbW9kdWxlLCAncGFja2FnZS5qc29uJ1xuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAndXRmOCdcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBwYWNrYWdlSnNvbiA9IHt9O1xuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCBiaW5zID0gKCdiaW4nIGluIHBhY2thZ2VKc29uICYmIHR5cGVvZiBwYWNrYWdlSnNvbi5iaW4gPT09ICdvYmplY3QnKSA/IE9iamVjdC5rZXlzKHBhY2thZ2VKc29uLmJpbikgOiBbXTtcblxuICAgICAgICBpZiAoYmlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBiaW5zLmZvckVhY2goKGJpbikgPT4ge1xuICAgICAgICAgICAgICAgIGV4dC5mb3JFYWNoKChleHRlbnNpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluRmlsZVBhdGggPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmFwcFJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbm9kZV9tb2R1bGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcuYmluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2Jpbn0ke2V4dGVuc2lvbn1gXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiQudXRpbHMuZXhpc3RzKGJpbkZpbGVQYXRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kLnV0aWxzLnN5bWxpbmtFeGlzdHMoYmluRmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMucmVuYW1lU3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5GaWxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAuZXh0cmFjdGVkTm9kZU1vZHVsZXNCaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2Jpbn0ke2V4dGVuc2lvbn1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgYGV4dHJhY3RgIGZpZWxkIHdpdGggYXV0b21hdGljYWxseSBkZXRlY3RlZCBtb2R1bGVzLlxuICAgICAqL1xuICAgIGdldE1vZHVsZXNUb0V4dHJhY3QoKSB7XG4gICAgICAgIGNvbnN0IGJpbmFyeU1vZHVsZXNEZXRlY3RvciA9XG4gICAgICAgICAgICBuZXcgQmluYXJ5TW9kdWxlRGV0ZWN0b3IodGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5ub2RlTW9kdWxlcyk7XG4gICAgICAgIGNvbnN0IHRvQmVFeHRyYWN0ZWQgPSBiaW5hcnlNb2R1bGVzRGV0ZWN0b3IuZGV0ZWN0KCk7XG5cbiAgICAgICAgbGV0IHsgZXh0cmFjdCB9ID0gdGhpcy4kLmRlc2t0b3AuZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXh0cmFjdCkpIHtcbiAgICAgICAgICAgIGV4dHJhY3QgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lcmdlID0ge307XG4gICAgICAgIHRvQmVFeHRyYWN0ZWQuY29uY2F0KGV4dHJhY3QpLmZvckVhY2gobW9kdWxlID0+IHtcbiAgICAgICAgICAgIG1lcmdlW21vZHVsZV0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZXh0cmFjdCA9IE9iamVjdC5rZXlzKG1lcmdlKTtcbiAgICAgICAgaWYgKGV4dHJhY3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sb2cudmVyYm9zZShgcmVzdWx0YW50IG1vZHVsZXMgdG8gZXh0cmFjdCBsaXN0IGlzOiAke2V4dHJhY3Quam9pbignLCAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0cmFjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGEgbWQ1IGZyb20gYWxsIGRlcGVuZGVuY2llcy5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVDb21wYXRpYmlsaXR5VmVyc2lvbigpIHtcbiAgICAgICAgdGhpcy5sb2cudmVyYm9zZSgnY2FsY3VsYXRpbmcgY29tcGF0aWJpbGl0eSB2ZXJzaW9uJyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy4kLmRlc2t0b3AuZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICBpZiAoKCdkZXNrdG9wSENQQ29tcGF0aWJpbGl0eVZlcnNpb24nIGluIHNldHRpbmdzKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wYXRpYmlsaXR5VmVyc2lvbiA9IGAke3NldHRpbmdzLmRlc2t0b3BIQ1BDb21wYXRpYmlsaXR5VmVyc2lvbn1gO1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybihgY29tcGF0aWJpbGl0eSB2ZXJzaW9uIG92ZXJyaWRkZW4gdG8gJHt0aGlzLmNvbXBhdGliaWxpdHlWZXJzaW9ufWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWQ1ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNScpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBzTWFuYWdlci5nZXREZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgY29uc3QgZGVwZW5kZW5jaWVzU29ydGVkID0gT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzKS5zb3J0KCk7XG4gICAgICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc1NvcnRlZC5tYXAoZGVwZW5kZW5jeSA9PlxuICAgICAgICAgICAgYCR7ZGVwZW5kZW5jeX06JHtkZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV19YCk7XG4gICAgICAgIGNvbnN0IG1haW5Db21wYXRpYmlsaXR5VmVyc2lvbiA9IHRoaXMuJC5nZXRWZXJzaW9uKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ21ldGVvci1kZXNrdG9wIGNvbXBhdGliaWxpdHkgdmVyc2lvbiBpcyAnLFxuICAgICAgICAgICAgYCR7bWFpbkNvbXBhdGliaWxpdHlWZXJzaW9uWzBdfS4ke21haW5Db21wYXRpYmlsaXR5VmVyc2lvblsxXX1gKTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goXG4gICAgICAgICAgICBgbWV0ZW9yLWRlc2t0b3A6JHttYWluQ29tcGF0aWJpbGl0eVZlcnNpb25bMF19LiR7bWFpbkNvbXBhdGliaWxpdHlWZXJzaW9uWzFdfWBcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBkZXNrdG9wQ29tcGF0aWJpbGl0eVZlcnNpb24gPSBzZXR0aW5ncy52ZXJzaW9uLnNwbGl0KCcuJylbMF07XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCcuZGVza3RvcCBjb21wYXRpYmlsaXR5IHZlcnNpb24gaXMgJywgZGVza3RvcENvbXBhdGliaWxpdHlWZXJzaW9uKTtcbiAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goXG4gICAgICAgICAgICBgZGVza3RvcC1hcHA6JHtkZXNrdG9wQ29tcGF0aWJpbGl0eVZlcnNpb259YFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5NRVRFT1JfREVTS1RPUF9ERUJVR19ERVNLVE9QX0NPTVBBVElCSUxJVFlfVkVSU0lPTiB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTUVURU9SX0RFU0tUT1BfREVCVUdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhgY29tcGF0aWJpbGl0eSB2ZXJzaW9uIGNhbGN1bGF0ZWQgZnJvbSAke0pTT04uc3RyaW5naWZ5KGRlcGVuZGVuY2llcyl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBtZDUudXBkYXRlKEpTT04uc3RyaW5naWZ5KGRlcGVuZGVuY2llcykpO1xuXG4gICAgICAgIHRoaXMuY29tcGF0aWJpbGl0eVZlcnNpb24gPSBtZDUuZGlnZXN0KCdoZXgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGFsbCBuZWNlc3NhcnkgdGFza3MgdG8gYnVpbGQgdGhlIGRlc2t0b3BpZmllZCBhcHAuXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGQocnVuID0gZmFsc2UpIHtcbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdG8gYSB0YXNrIHJ1bm5lclxuICAgICAgICB0aGlzLmxvZy5pbmZvKCdzY2FmZm9sZGluZycpO1xuXG4gICAgICAgIGlmICghdGhpcy4kLmRlc2t0b3AuY2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiQuZW52Lm9wdGlvbnMuc2NhZmZvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignc2VlbXMgdGhhdCB5b3UgZG8gbm90IGhhdmUgYSAuZGVza3RvcCBkaXIgaW4geW91ciBwcm9qZWN0IG9yIGl0IGlzJyArXG4gICAgICAgICAgICAgICAgICAgICcgY29ycnVwdGVkLiBSdW4gXFwnbnBtIHJ1biBkZXNrdG9wIC0tIGluaXRcXCcgdG8gZ2V0IGEgbmV3IG9uZS4nKTtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZmFpbCwgc28gdGhhdCBucG0gd2lsbCBub3QgcHJpbnQgaGlzIGVycm9yIHN0dWZmIHRvIGNvbnNvbGUuXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiQuZGVza3RvcC5zY2FmZm9sZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuJC5tZXRlb3JBcHAudXBkYXRlR2l0SWdub3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy4kLm1ldGVvckFwcC51cGRhdGVHaXRJZ25vcmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybihgZXJyb3Igb2NjdXJyZWQgd2hpbGUgYWRkaW5nICR7dGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5yb290TmFtZX1gICtcbiAgICAgICAgICAgICAgICAndG8gLmdpdGlnbm9yZTogJywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4kLm1ldGVvckFwcC5lbnN1cmVEZXNrdG9wSENQUGFja2FnZXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHdoaWxlIGNoZWNraW5nIGZvciByZXF1aXJlZCBwYWNrYWdlczogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zY2FmZm9sZC5tYWtlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciB3aGlsZSBzY2FmZm9sZGluZzogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYWNrYWdlSnNvbkZpZWxkcygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igd2hpbGUgdXBkYXRpbmcgcGFja2FnZS5qc29uOiAnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURlcGVuZGVuY2llc0xpc3QoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHdoaWxlIG1lcmdpbmcgZGVwZW5kZW5jaWVzIGxpc3Q6ICcsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQ29tcGF0aWJpbGl0eVZlcnNpb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHdoaWxlIGNhbGN1bGF0aW5nIGNvbXBhdGliaWxpdHkgdmVyc2lvbjogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVUZW1wb3JhcnlOb2RlTW9kdWxlcygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igb2NjdXJyZWQgd2hpbGUgaGFuZGxpbmcgdGVtcG9yYXJ5IG5vZGVfbW9kdWxlczogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZU1vZHVsZXNSZW1vdmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZU1vZHVsZXNSZW1vdmVkID0gYXdhaXQgdGhpcy5oYW5kbGVTdGF0ZU9mTm9kZU1vZHVsZXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIG9jY3VycmVkIHdoaWxlIGNsZWFyaW5nIG5vZGVfbW9kdWxlczogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5saW5rTnBtUGFja2FnZXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoYGxpbmtpbmcgcGFja2FnZXMgZmFpbGVkOiAke2V9YCk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWJ1aWxkRGVwcyh0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIG9jY3VycmVkIHdoaWxlIGluc3RhbGxpbmcgbm9kZV9tb2R1bGVzOiAnLCBlKTtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbm9kZU1vZHVsZXNSZW1vdmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVidWlsZERlcHMoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVidWlsZGluZyBuYXRpdmUgbm9kZSBtb2R1bGVzOiAnLCBlKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsTG9jYWxOb2RlTW9kdWxlcygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igb2NjdXJyZWQgd2hpbGUgaW5zdGFsbGluZyBsb2NhbCBub2RlIG1vZHVsZXM6ICcsIGUpO1xuICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgICB9XG5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5lbnN1cmVNZXRlb3JEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIG9jY3VycmVkIHdoaWxlIGVuc3VyaW5nIG1ldGVvciBkZXBlbmRlbmNpZXMgYXJlIGluc3RhbGxlZDogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0aGlzLiQuZW52LmlzUHJvZHVjdGlvbkJ1aWxkKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wYWNrU2tlbGV0b25Ub0FzYXIoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igd2hpbGUgcGFja2luZyBza2VsZXRvbiB0byBhc2FyOiAnLCBlKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIGNvcHlpbmcgLmRlc2t0b3AgdG8gYSB0ZW1wIGxvY2F0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvcHlEZXNrdG9wVG9EZXNrdG9wVGVtcCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igd2hpbGUgY29weWluZyAuZGVza3RvcCB0byBhIHRlbXBvcmFyeSBsb2NhdGlvbjogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZXR0aW5nc0pzb25GaWVsZHMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHdoaWxlIHVwZGF0aW5nIHNldHRpbmdzLmpzb246ICcsIGUpO1xuICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZXhjbHVkZUZpbGVzRnJvbUFyY2hpdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHdoaWxlIGV4Y2x1ZGluZyBmaWxlcyBmcm9tIHBhY2tpbmcgdG8gYXNhcjogJywgZSk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BpbGVBbmRNaW5pZnkoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHdoaWxlIHRyYW5zcGlsaW5nIG9yIG1pbmlmeWluZzogJywgZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYWNrRGVza3RvcFRvQXNhcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5lcnJvcignZXJyb3Igb2NjdXJyZWQgd2hpbGUgcGFja2luZyAuZGVza3RvcCB0byBhc2FyOiAnLCBlKTtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmdldE1ldGVvckNsaWVudEJ1aWxkKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdlcnJvciBvY2N1cnJlZCBkdXJpbmcgZ2V0dGluZyBtZXRlb3IgbW9iaWxlIGJ1aWxkOiAnLCBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydW4pIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3J1bm5pbmcnKTtcbiAgICAgICAgICAgIHRoaXMuJC5lbGVjdHJvbi5ydW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2J1aWx0Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGFsbCByZXF1aXJlZCBkZXBlbmRlbmNpZXMgYXJlIGFkZGVkIHRvIHRoZSBNZXRlb3IgcHJvamVjdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZS48dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgZW5zdXJlTWV0ZW9yRGVwZW5kZW5jaWVzKCkge1xuICAgICAgICBjb25zdCBwYWNrYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCBwYWNrYWdlc1dpdGhWZXJzaW9uID0gW107XG4gICAgICAgIGxldCBwbHVnaW5zID0gJ3BsdWdpbnMgWyc7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy4kLmRlc2t0b3AuZ2V0RGVwZW5kZW5jaWVzKCkucGx1Z2lucykuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICAvLyBSZWFkIHBhY2thZ2UuanNvbiBvZiB0aGUgcGx1Z2luLlxuICAgICAgICAgICAgY29uc3QgcGFja2FnZUpzb24gPVxuICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgIGZzLnJlYWRGaWxlU3luYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLm5vZGVNb2R1bGVzLCBwbHVnaW4sICdwYWNrYWdlLmpzb24nXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3V0ZjgnXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoJ21ldGVvckRlcGVuZGVuY2llcycgaW4gcGFja2FnZUpzb24gJiYgdHlwZW9mIHBhY2thZ2VKc29uLm1ldGVvckRlcGVuZGVuY2llcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBwbHVnaW5zICs9IGAke3BsdWdpbn0sIGA7XG4gICAgICAgICAgICAgICAgcGFja2FnZXMudW5zaGlmdCguLi5PYmplY3Qua2V5cyhwYWNrYWdlSnNvbi5tZXRlb3JEZXBlbmRlbmNpZXMpKTtcbiAgICAgICAgICAgICAgICBwYWNrYWdlc1dpdGhWZXJzaW9uLnVuc2hpZnQoLi4ucGFja2FnZXMubWFwKChwYWNrYWdlTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFja2FnZUpzb24ubWV0ZW9yRGVwZW5kZW5jaWVzW3BhY2thZ2VOYW1lXSA9PT0gJ0B2ZXJzaW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3BhY2thZ2VOYW1lfUAke3BhY2thZ2VKc29uLnZlcnNpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7cGFja2FnZU5hbWV9QCR7cGFja2FnZUpzb24ubWV0ZW9yRGVwZW5kZW5jaWVzW3BhY2thZ2VOYW1lXX1gO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhY2thZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBsdWdpbnMgPSBgJHtwbHVnaW5zLnN1YnN0cigwLCBwbHVnaW5zLmxlbmd0aCAtIDIpfV1gO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLiQubWV0ZW9yQXBwLm1ldGVvck1hbmFnZXIuZW5zdXJlUGFja2FnZXMoXG4gICAgICAgICAgICAgICAgICAgIHBhY2thZ2VzLCBwYWNrYWdlc1dpdGhWZXJzaW9uLCBwbHVnaW5zXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgbWV0ZW9yIGFwcC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRNZXRlb3JDbGllbnRCdWlsZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy4kLm1ldGVvckFwcC5idWlsZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbm9kZV9tb2R1bGVzIGlmIG5lZWRlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVTdGF0ZU9mTm9kZU1vZHVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLiQuZW52LmlzUHJvZHVjdGlvbkJ1aWxkKCkgfHwgdGhpcy4kLmVudi5vcHRpb25zLmlhMzIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy4kLmVudi5pc1Byb2R1Y3Rpb25CdWlsZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnY2xlYXJpbmcgbm9kZV9tb2R1bGVzIGJlY2F1c2Ugd2UgbmVlZCB0byBoYXZlIGl0IGNsZWFyIGZvciBpYTMyIHJlYnVpbGQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnY2xlYXJpbmcgbm9kZV9tb2R1bGVzIGJlY2F1c2UgdGhpcyBpcyBhIHByb2R1Y3Rpb24gYnVpbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy4kLnV0aWxzLnJtV2l0aFJldHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICctcmYnLCB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLm5vZGVNb2R1bGVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgYSB0ZW1wb3Jhcnkgbm9kZV9tb2R1bGVzIGZvbGRlciBhbmQgbm8gbm9kZV9tb2R1bGVzIGZvbGRlciwgd2Ugd2lsbFxuICAgICAqIHJlc3RvcmUgaXQsIGFzIGl0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgZnJvbSBhbiBpbnRlcnJ1cHRlZCBmbG93LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZVRlbXBvcmFyeU5vZGVNb2R1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy4kLnV0aWxzLmV4aXN0cyh0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLnRtcE5vZGVNb2R1bGVzKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiQudXRpbHMuZXhpc3RzKHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAubm9kZU1vZHVsZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ21vdmluZyB0ZW1wIG5vZGVfbW9kdWxlcyBiYWNrJyk7XG4gICAgICAgICAgICAgICAgc2hlbGwubXYoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAudG1wTm9kZU1vZHVsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAubm9kZU1vZHVsZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG5vZGVfbW9kdWxlcyBmb2xkZXIsIHdlIHNob3VsZCBjbGVhciB0aGUgdGVtcG9yYXJ5IG9uZS5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnY2xlYXJpbmcgdGVtcCBub2RlX21vZHVsZXMgYmVjYXVzZSBuZXcgb25lIGlzIGFscmVhZHkgY3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuJC51dGlscy5ybVdpdGhSZXRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgJy1yZicsIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAudG1wTm9kZU1vZHVsZXNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOT1QgSU4gVVNFIFJJR0hUIE5PVyAvLyBERVBSRUNBVEVEXG4gICAgICpcbiAgICAgKiBXcmFwcGVyIGZvciBzcGF3bmluZyBucG0uXG4gICAgICogQHBhcmFtIHtBcnJheX0gIGNvbW1hbmRzIC0gY29tbWFuZHMgZm9yIHNwYXduXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ZGlvXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBydW5OcG0oY29tbWFuZHMsIHN0ZGlvID0gJ2lnbm9yZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gcnVuIG5wbSB3aXRob3V0IGRlcGVuZGluZyBvbiBpdCBjYXVzZSBpdCdzIGEgaHVnZSBkZXBlbmRlbmN5LlxuICAgICAgICAgICAgbGV0IG5wbSA9IHBhdGguam9pbihcbiAgICAgICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLm1ldGVvckFwcC5yb290LCAnbm9kZV9tb2R1bGVzJywgJy5iaW4nLCAnbnBtJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLiQudXRpbHMuZXhpc3RzKG5wbSkpIHtcbiAgICAgICAgICAgICAgICBucG0gPSBwYXRoLmpvaW4oXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMubWV0ZW9yQXBwLnJvb3QsICdub2RlX21vZHVsZXMnLCAnbWV0ZW9yLWRlc2t0b3AnLCAnbm9kZV9tb2R1bGVzJywgJy5iaW4nLCAnbnBtJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy4kLnV0aWxzLmV4aXN0cyhucG0pKSB7XG4gICAgICAgICAgICAgICAgbnBtID0gc2hlbGwud2hpY2goJ25wbScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvZy52ZXJib3NlKGBleGVjdXRpbmcgbnBtICR7Y29tbWFuZHMuam9pbignICcpfWApO1xuXG4gICAgICAgICAgICBzcGF3bihucG0sIGNvbW1hbmRzLCB7XG4gICAgICAgICAgICAgICAgY3dkOiB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLnJvb3QsXG4gICAgICAgICAgICAgICAgc3RkaW9cbiAgICAgICAgICAgIH0pLm9uKCdleGl0JywgY29kZSA9PiAoXG4gICAgICAgICAgICAgICAgKGNvZGUgPT09IDApID8gcmVzb2x2ZSgpIDogcmVqZWN0KG5ldyBFcnJvcihgbnBtIGV4aXQgY29kZSB3YXMgJHtjb2RlfWApKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUnVucyBucG0gbGluayBmb3IgZXZlcnkgcGFja2FnZSBzcGVjaWZpZWQgaW4gc2V0dGluZ3MuanNvbi0+bGlua1BhY2thZ2VzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpbmtOcG1QYWNrYWdlcygpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLiQuZGVza3RvcC5nZXRTZXR0aW5ncygpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBpZiAoJ2xpbmtQYWNrYWdlcycgaW4gdGhpcy4kLmRlc2t0b3AuZ2V0U2V0dGluZ3MoKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3MubGlua1BhY2thZ2VzKSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmxpbmtQYWNrYWdlcy5mb3JFYWNoKHBhY2thZ2VOYW1lID0+XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5ydW5OcG0oWydsaW5rJywgcGFja2FnZU5hbWVdKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIG5wbSBpbiB0aGUgZWxlY3Ryb24gYXBwIHRvIGdldCB0aGUgZGVwZW5kZW5jaWVzIGluc3RhbGxlZC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVEZXBzKCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdpbnN0YWxsaW5nIGRlcGVuZGVuY2llcycpO1xuICAgICAgICBpZiAodGhpcy4kLnV0aWxzLmV4aXN0cyh0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLm5vZGVNb2R1bGVzKSkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3J1bm5pbmcgbnBtIHBydW5lIHRvIHdpcGUgdW5uZWVkZWQgZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTnBtKFsncHJ1bmUnXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJ1bk5wbShbJ2luc3RhbGwnXSwgdGhpcy4kLmVudi5zdGRpbyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhcm5zIGlmIHBsdWdpbnMgdmVyc2lvbiBhcmUgb3V0ZGF0ZWQgaW4gY29tcGFyZSB0byB0aGUgbmV3ZXN0IHNjYWZmb2xkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5zVmVyc2lvbnMgLSBjdXJyZW50IHBsdWdpbnMgdmVyc2lvbnMgZnJvbSBzZXR0aW5ncy5qc29uXG4gICAgICovXG4gICAgY2hlY2tQbHVnaW5zVmVyc2lvbihwbHVnaW5zVmVyc2lvbnMpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NKc29uID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgIGZzLnJlYWRGaWxlU3luYyhwYXRoLmpvaW4odGhpcy4kLmVudi5wYXRocy5zY2FmZm9sZCwgJ3NldHRpbmdzLmpzb24nKSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc2NhZmZvbGRQbHVnaW5zVmVyc2lvbiA9IHRoaXMuJC5kZXNrdG9wLmdldERlcGVuZGVuY2llcyhzZXR0aW5nc0pzb24sIGZhbHNlKS5wbHVnaW5zO1xuICAgICAgICBPYmplY3Qua2V5cyhwbHVnaW5zVmVyc2lvbnMpLmZvckVhY2goKHBsdWdpbk5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwbHVnaW5OYW1lIGluIHNjYWZmb2xkUGx1Z2luc1ZlcnNpb24gJiZcbiAgICAgICAgICAgICAgICBzY2FmZm9sZFBsdWdpbnNWZXJzaW9uW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5zVmVyc2lvbnNbcGx1Z2luTmFtZV0gJiZcbiAgICAgICAgICAgICAgICBzZW12ZXIubHQocGx1Z2luc1ZlcnNpb25zW3BsdWdpbk5hbWVdLCBzY2FmZm9sZFBsdWdpbnNWZXJzaW9uW3BsdWdpbk5hbWVdKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cud2FybihgeW91IGFyZSB1c2luZyBvdXRkYXRlZCB2ZXJzaW9uICR7cGx1Z2luc1ZlcnNpb25zW3BsdWdpbk5hbWVdfSBvZiBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7cGx1Z2luTmFtZX0sIHRoZSBzdWdnZXN0ZWQgdmVyc2lvbiB0byB1c2UgaXMgYCArXG4gICAgICAgICAgICAgICAgICAgIGAke3NjYWZmb2xkUGx1Z2luc1ZlcnNpb25bcGx1Z2luTmFtZV19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBjb3JlIGRlcGVuZGVuY3kgbGlzdCB3aXRoIHRoZSBkZXBlbmRlbmNpZXMgZnJvbSAuZGVza3RvcC5cbiAgICAgKi9cbiAgICB1cGRhdGVEZXBlbmRlbmNpZXNMaXN0KCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCd1cGRhdGluZyBsaXN0IG9mIHBhY2thZ2UuanNvblxcJ3MgZGVwZW5kZW5jaWVzJyk7XG4gICAgICAgIGNvbnN0IGRlc2t0b3BEZXBlbmRlbmNpZXMgPSB0aGlzLiQuZGVza3RvcC5nZXREZXBlbmRlbmNpZXMoKTtcblxuICAgICAgICB0aGlzLmNoZWNrUGx1Z2luc1ZlcnNpb24oZGVza3RvcERlcGVuZGVuY2llcy5wbHVnaW5zKTtcblxuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnbWVyZ2luZyBzZXR0aW5ncy5qc29uW2RlcGVuZGVuY2llc10nKTtcbiAgICAgICAgdGhpcy5kZXBzTWFuYWdlci5tZXJnZURlcGVuZGVuY2llcyhcbiAgICAgICAgICAgICdzZXR0aW5ncy5qc29uW2RlcGVuZGVuY2llc10nLFxuICAgICAgICAgICAgZGVza3RvcERlcGVuZGVuY2llcy5mcm9tU2V0dGluZ3NcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ21lcmdpbmcgc2V0dGluZ3MuanNvbltwbHVnaW5zXScpO1xuICAgICAgICB0aGlzLmRlcHNNYW5hZ2VyLm1lcmdlRGVwZW5kZW5jaWVzKFxuICAgICAgICAgICAgJ3NldHRpbmdzLmpzb25bcGx1Z2luc10nLFxuICAgICAgICAgICAgZGVza3RvcERlcGVuZGVuY2llcy5wbHVnaW5zXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ21lcmdpbmcgZGVwZW5kZW5jaWVzIGZyb20gbW9kdWxlcycpO1xuICAgICAgICBPYmplY3Qua2V5cyhkZXNrdG9wRGVwZW5kZW5jaWVzLm1vZHVsZXMpLmZvckVhY2gobW9kdWxlID0+XG4gICAgICAgICAgICB0aGlzLmRlcHNNYW5hZ2VyLm1lcmdlRGVwZW5kZW5jaWVzKFxuICAgICAgICAgICAgICAgIGBtb2R1bGVbJHttb2R1bGV9XWAsXG4gICAgICAgICAgICAgICAgZGVza3RvcERlcGVuZGVuY2llcy5tb2R1bGVzW21vZHVsZV1cbiAgICAgICAgICAgICkpO1xuXG4gICAgICAgIHRoaXMucGFja2FnZUpzb24uZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBzTWFuYWdlci5nZXRSZW1vdGVEZXBlbmRlbmNpZXMoKTtcbiAgICAgICAgdGhpcy5wYWNrYWdlSnNvbi5sb2NhbERlcGVuZGVuY2llcyA9IHRoaXMuZGVwc01hbmFnZXIuZ2V0TG9jYWxEZXBlbmRlbmNpZXMoKTtcblxuICAgICAgICB0aGlzLmxvZy5kZWJ1Zygnd3JpdGluZyB1cGRhdGVkIHBhY2thZ2UuanNvbicpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKFxuICAgICAgICAgICAgdGhpcy4kLmVudi5wYXRocy5lbGVjdHJvbkFwcC5wYWNrYWdlSnNvbiwgSlNPTi5zdHJpbmdpZnkodGhpcy5wYWNrYWdlSnNvbiwgbnVsbCwgMilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnN0YWxsIG5vZGUgbW9kdWxlcyBmcm9tIGxvY2FsIHBhdGhzIHVzaW5nIGxvY2FsLWluc3RhbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJjaFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGluc3RhbGxMb2NhbE5vZGVNb2R1bGVzKGFyY2ggPSB0aGlzLiQuZW52Lm9wdGlvbnMuaWEzMiB8fCBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJyA/ICdpYTMyJyA6ICd4NjQnKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsRGVwZW5kZW5jaWVzID0gXy52YWx1ZXModGhpcy5wYWNrYWdlSnNvbi5sb2NhbERlcGVuZGVuY2llcyk7XG4gICAgICAgIGlmIChsb2NhbERlcGVuZGVuY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5pbmZvKCdpbnN0YWxsaW5nIGxvY2FsIG5vZGUgbW9kdWxlcycpO1xuICAgICAgICBjb25zdCBsYXN0UmVidWlsZCA9IHRoaXMuJC5lbGVjdHJvbkJ1aWxkZXIucHJlcGFyZUxhc3RSZWJ1aWxkT2JqZWN0KGFyY2gpO1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRHeXBFbnYobGFzdFJlYnVpbGQuZnJhbWV3b3JrSW5mbywgbGFzdFJlYnVpbGQucGxhdGZvcm0sIGxhc3RSZWJ1aWxkLmFyY2gpO1xuICAgICAgICBjb25zdCBpbnN0YWxsZXIgPSBuZXcgTG9jYWxJbnN0YWxsZXIoXG4gICAgICAgICAgICB7IFt0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLnJvb3RdOiBsb2NhbERlcGVuZGVuY2llcyB9LFxuICAgICAgICAgICAgeyBucG1FbnY6IGVudiB9XG4gICAgICAgICk7XG4gICAgICAgIHByb2dyZXNzKGluc3RhbGxlcik7XG4gICAgICAgIHJldHVybiBpbnN0YWxsZXIuaW5zdGFsbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYnVpbGQgYmluYXJ5IGRlcGVuZGVuY2llcyBhZ2FpbnN0IEVsZWN0cm9uJ3Mgbm9kZSBoZWFkZXJzLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHJlYnVpbGREZXBzKGluc3RhbGwgPSBmYWxzZSkge1xuICAgICAgICBpZiAoaW5zdGFsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygnaXNzdWluZyBub2RlX21vZHVsZXMgaW5zdGFsbCBmcm9tIGVsZWN0cm9uLWJ1aWxkZXInKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2lzc3VpbmcgbmF0aXZlIG1vZHVsZXMgcmVidWlsZCBmcm9tIGVsZWN0cm9uLWJ1aWxkZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFyY2ggPSB0aGlzLiQuZW52Lm9wdGlvbnMuaWEzMiB8fCBwcm9jZXNzLmFyY2ggPT09ICdpYTMyJyA/ICdpYTMyJyA6ICd4NjQnO1xuXG4gICAgICAgIGlmICh0aGlzLiQuZW52Lm9wdGlvbnMuaWEzMikge1xuICAgICAgICAgICAgdGhpcy5sb2cudmVyYm9zZSgnZm9yY2luZyByZWJ1aWxkIGZvciAzMmJpdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cudmVyYm9zZShgcmVidWlsZGluZyBmb3IgJHthcmNofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJC5lbGVjdHJvbkJ1aWxkZXIuaW5zdGFsbE9yUmVidWlsZChhcmNoLCB1bmRlZmluZWQsIGluc3RhbGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwYWNrYWdlLmpzb24gZmllbGRzIGFjY29yZGluZ2x5IHRvIHdoYXQgaXMgc2V0IGluIHNldHRpbmdzLmpzb24uXG4gICAgICpcbiAgICAgKiBwYWNrYWdlSnNvbi5uYW1lID0gc2V0dGluZ3MucHJvamVjdE5hbWVcbiAgICAgKiBwYWNrYWdlSnNvbi52ZXJzaW9uID0gc2V0dGluZ3MudmVyc2lvblxuICAgICAqIHBhY2thZ2VKc29uLiogPSBzZXR0aW5ncy5wYWNrYWdlSnNvbkZpZWxkc1xuICAgICAqL1xuICAgIHVwZGF0ZVBhY2thZ2VKc29uRmllbGRzKCkge1xuICAgICAgICB0aGlzLmxvZy52ZXJib3NlKCd1cGRhdGluZyBwYWNrYWdlLmpzb24gZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy4kLmRlc2t0b3AuZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgLyoqIEB0eXBlIHtkZXNrdG9wU2V0dGluZ3N9ICovXG4gICAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gdGhpcy5zY2FmZm9sZC5nZXREZWZhdWx0UGFja2FnZUpzb24oKTtcblxuICAgICAgICBwYWNrYWdlSnNvbi52ZXJzaW9uID0gc2V0dGluZ3MudmVyc2lvbjtcbiAgICAgICAgaWYgKCdwYWNrYWdlSnNvbkZpZWxkcycgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGFzc2lnbkluKHBhY2thZ2VKc29uLCBzZXR0aW5ncy5wYWNrYWdlSnNvbkZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduSW4ocGFja2FnZUpzb24sIHsgbmFtZTogc2V0dGluZ3MucHJvamVjdE5hbWUgfSk7XG5cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3dyaXRpbmcgdXBkYXRlZCBwYWNrYWdlLmpzb24nKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhcbiAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAucGFja2FnZUpzb24sIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCA0KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhY2thZ2VKc29uID0gcGFja2FnZUpzb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzZXR0aW5ncy5qc29uIHdpdGggZW52IChwcm9kL2RldikgaW5mb3JtYXRpb24gYW5kIHZlcnNpb25zLlxuICAgICAqL1xuICAgIHVwZGF0ZVNldHRpbmdzSnNvbkZpZWxkcygpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0aW5nIHNldHRpbmdzLmpzb24gZmllbGRzJyk7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGhpcy4kLmRlc2t0b3AuZ2V0U2V0dGluZ3MoKTtcblxuICAgICAgICAvLyBTYXZlIHZlcnNpb25zLlxuICAgICAgICBzZXR0aW5ncy5jb21wYXRpYmlsaXR5VmVyc2lvbiA9IHRoaXMuY29tcGF0aWJpbGl0eVZlcnNpb247XG5cbiAgICAgICAgLy8gUGFzcyBpbmZvcm1hdGlvbiBhYm91dCBidWlsZCB0eXBlIHRvIHRoZSBzZXR0aW5ncy5qc29uLlxuICAgICAgICBzZXR0aW5ncy5lbnYgPSAodGhpcy4kLmVudi5pc1Byb2R1Y3Rpb25CdWlsZCgpKSA/XG4gICAgICAgICAgICAncHJvZCcgOiAnZGV2JztcblxuICAgICAgICBzZXR0aW5ncy5kZXNrdG9wVmVyc2lvbiA9IGAke3RoaXMuJC5kZXNrdG9wLmdldEhhc2hWZXJzaW9uKCl9XyR7c2V0dGluZ3MuZW52fWA7XG5cbiAgICAgICAgc2V0dGluZ3MubWV0ZW9yRGVza3RvcFZlcnNpb24gPSB0aGlzLiQuZ2V0VmVyc2lvbigpO1xuXG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoXG4gICAgICAgICAgICB0aGlzLiQuZW52LnBhdGhzLmRlc2t0b3BUbXAuc2V0dGluZ3MsIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzLCBudWxsLCA0KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBmaWxlcyBmcm9tIHByZXBhcmVkIC5kZXNrdG9wIHRvIGRlc2t0b3AuYXNhciBpbiBlbGVjdHJvbiBhcHAuXG4gICAgICovXG4gICAgcGFja0Rlc2t0b3BUb0FzYXIoKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oJ3BhY2tpbmcgLmRlc2t0b3AgdG8gYXNhcicpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXNhci5jcmVhdGVQYWNrYWdlKFxuICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZGVza3RvcFRtcC5yb290LFxuICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAuZGVza3RvcEFzYXIsXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZy52ZXJib3NlKCdjbGVhcmluZyB0ZW1wb3JhcnkgLmRlc2t0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kLnV0aWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAucm1XaXRoUmV0cmllcygnLXJmJywgdGhpcy4kLmVudi5wYXRocy5kZXNrdG9wVG1wLnJvb3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSB0ZW1wb3JhcnkgY29weSBvZiAuZGVza3RvcC5cbiAgICAgKi9cbiAgICBjb3B5RGVza3RvcFRvRGVza3RvcFRlbXAoKSB7XG4gICAgICAgIHRoaXMubG9nLnZlcmJvc2UoJ2NvcHlpbmcgLmRlc2t0b3AgdG8gdGVtcG9yYXJ5IGxvY2F0aW9uJyk7XG4gICAgICAgIHNoZWxsLmNwKCctcmYnLCB0aGlzLiQuZW52LnBhdGhzLmRlc2t0b3Aucm9vdCwgdGhpcy4kLmVudi5wYXRocy5kZXNrdG9wVG1wLnJvb3QpO1xuICAgICAgICAvLyBSZW1vdmUgdGVzdCBmaWxlcy5cbiAgICAgICAgZGVsLnN5bmMoW1xuICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuJC5lbnYucGF0aHMuZGVza3RvcFRtcC5yb290LCAnKionLCAnKi50ZXN0LmpzJylcbiAgICAgICAgXSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGJhYmVsIGFuZCB1Z2xpZnkgb3ZlciAuZGVza3RvcCBpZiByZXF1ZXN0ZWQuXG4gICAgICovXG4gICAgdHJhbnNwaWxlQW5kTWluaWZ5KCkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCd0cmFuc3BpbGluZyBhbmQgdWdsaWZ5aW5nJyk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLiQuZGVza3RvcC5nZXRTZXR0aW5ncygpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gJ3VnbGlmeU9wdGlvbnMnIGluIHNldHRpbmdzID8gc2V0dGluZ3MudWdsaWZ5T3B0aW9ucyA6IHt9O1xuXG4gICAgICAgIGNvbnN0IHVnbGlmeWluZ0VuYWJsZWQgPSAndWdsaWZ5JyBpbiBzZXR0aW5ncyAmJiAhIXNldHRpbmdzLnVnbGlmeTtcblxuICAgICAgICBjb25zdCBwcmVzZXQgPSBwcmVzZXRFbnYodW5kZWZpbmVkLCB7IHRhcmdldHM6IHsgbm9kZTogJzgnIH0gfSk7XG5cbiAgICAgICAgZ2xvYi5zeW5jKGAke3RoaXMuJC5lbnYucGF0aHMuZGVza3RvcFRtcC5yb290fS8qKi8qLmpzYCkuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29kZSB9ID0gdHJhbnNmb3JtRmlsZVN5bmMoZmlsZSwge1xuICAgICAgICAgICAgICAgIHByZXNldHM6IFtwcmVzZXRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbnYgPT09ICdwcm9kJyAmJiB1Z2xpZnlpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgKHsgY29kZSwgZXJyb3IgfSA9IHVnbGlmeS5taW5pZnkoY29kZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgY29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFsbCB0aGUgZmlsZXMgdGhhdCBzaG91bGQgbm90IGJlIHBhY2tlZCBpbnRvIGFzYXIgaW50byBhIHNhZmUgbG9jYXRpb24gd2hpY2ggaXMgdGhlXG4gICAgICogJ2V4dHJhY3RlZCcgZGlyIGluIHRoZSBlbGVjdHJvbiBhcHAuXG4gICAgICovXG4gICAgYXN5bmMgZXhjbHVkZUZpbGVzRnJvbUFyY2hpdmUoKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oJ2V4Y2x1ZGluZyBmaWxlcyBmcm9tIHBhY2tpbmcnKTtcblxuICAgICAgICAvLyBFbnN1cmUgZW1wdHkgYGV4dHJhY3RlZGAgZGlyXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuJC51dGlscy5ybVdpdGhSZXRyaWVzKCctcmYnLCB0aGlzLiQuZW52LnBhdGhzLmVsZWN0cm9uQXBwLmV4dHJhY3RlZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNoZWxsLm1rZGlyKHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAuZXh0cmFjdGVkKTtcblxuICAgICAgICBjb25zdCBjb25maWdzID0gdGhpcy4kLmRlc2t0b3AuZ2F0aGVyTW9kdWxlQ29uZmlncygpO1xuXG4gICAgICAgIC8vIE1vdmUgZmlsZXMgdGhhdCBzaG91bGQgbm90IGJlIGFzYXInZWQuXG4gICAgICAgIGNvbmZpZ3MuZm9yRWFjaCgoY29uZmlnKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2R1bGVDb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICBpZiAoJ2V4dHJhY3QnIGluIG1vZHVsZUNvbmZpZykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVDb25maWcuZXh0cmFjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlQ29uZmlnLmV4dHJhY3QgPSBbbW9kdWxlQ29uZmlnLmV4dHJhY3RdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2R1bGVDb25maWcuZXh0cmFjdC5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBleGNsdWRpbmcgJHtmaWxlfSBmcm9tICR7Y29uZmlnLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kLmVudi5wYXRocy5kZXNrdG9wVG1wLm1vZHVsZXMsIG1vZHVsZUNvbmZpZy5kaXJOYW1lLCBmaWxlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uUGF0aCA9IHBhdGguam9pbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJC5lbnYucGF0aHMuZWxlY3Ryb25BcHAuZXh0cmFjdGVkLCBtb2R1bGVDb25maWcuZGlyTmFtZVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy4kLnV0aWxzLmV4aXN0cyhkZXN0aW5hdGlvblBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGVsbC5ta2RpcihkZXN0aW5hdGlvblBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNoZWxsLm12KGZpbGVQYXRoLCBkZXN0aW5hdGlvblBhdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=