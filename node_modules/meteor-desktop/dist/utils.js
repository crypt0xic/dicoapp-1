'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

exports.exists = exists;
exports.rmWithRetries = rmWithRetries;
exports.readDir = readDir;
exports.getFileList = getFileList;
exports.readAndGetFileHash = readAndGetFileHash;
exports.computeHashForHashesSet = computeHashForHashesSet;
exports.readAndHashFiles = readAndHashFiles;
exports.readFilesAndComputeHash = readFilesAndComputeHash;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _shelljs = require('shelljs');

var _shelljs2 = _interopRequireDefault(_shelljs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Exists
 * @param {string} pathToCheck
 * @returns {boolean}
 */
/* eslint-disable consistent-return */
function exists(pathToCheck) {
    try {
        _fs2.default.accessSync(pathToCheck);
        return true;
    } catch (e) {
        return false;
    }
}

/**
 * Simple wrapper for shelljs.rm with additional retries in case of failure.
 * It is useful when something is concurrently reading the dir you want to remove.
 */
function rmWithRetries() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    var retries = 0;
    return new _promise2.default(function (resolve, reject) {
        function rm() {
            for (var _len2 = arguments.length, rmArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                rmArgs[_key2] = arguments[_key2];
            }

            try {
                _shelljs2.default.config.fatal = true;
                _shelljs2.default.rm.apply(_shelljs2.default, rmArgs);
                _shelljs2.default.config.reset();
                resolve();
            } catch (e) {
                retries += 1;
                if (retries < 5) {
                    setTimeout(function () {
                        rm.apply(undefined, rmArgs);
                    }, 100);
                } else {
                    _shelljs2.default.config.reset();
                    reject(e);
                }
            }
        }
        rm.apply(undefined, args);
    });
}

function readDir(dir, callback) {
    if (!callback) {
        return new _promise2.default(function (resolve, reject) {
            readDir(dir, function (err, data, stats) {
                if (err) {
                    reject(err);
                } else {
                    resolve({ data: data, stats: stats });
                }
            });
        });
    }
    var list = [];
    var allStats = {};

    _fs2.default.readdir(dir, function (err, files) {
        if (err) {
            return callback(err);
        }
        var pending = files.length;
        if (!pending) {
            return callback(null, list, allStats);
        }
        files.forEach(function (file) {
            var filePath = _path2.default.join(dir, file);
            _fs2.default.stat(filePath, function (_err, stats) {
                if (_err) {
                    return callback(_err);
                }
                if (stats.isDirectory()) {
                    readDir(filePath, function (__err, res, _allStats) {
                        if (__err) {
                            return callback(__err);
                        }
                        list = list.concat(res);
                        allStats = (0, _assign2.default)(allStats, _allStats);
                        pending -= 1;
                        if (!pending) {
                            return callback(null, list, allStats);
                        }
                    });
                } else {
                    list.push(filePath);
                    allStats[filePath] = {
                        size: stats.size,
                        dates: [stats.atime.getTime(), stats.birthtime.getTime(), stats.ctime.getTime(), stats.mtime.getTime()]
                    };
                    pending -= 1;
                    if (!pending) {
                        return callback(null, list, allStats);
                    }
                }
            });
        });
    });
}

/**
 * Returns a file list from a directory.
 * @param {string} dir - dir path
 * @param {boolean} sort - whether to apply sort
 * @returns {Promise<Array>}
 */
function getFileList(dir) {
    var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return new _promise2.default(function (resolve, reject) {
        readDir(dir, function (error, files) {
            if (error) {
                reject(error);
                return;
            }
            // eslint-disable-next-line no-param-reassign
            if (sort) {
                files = files.sort();
            }
            resolve(files);
        });
    });
}

/**
 * Returns file's hash.
 * @param {string} file - file path
 * @param {boolean} returnFileContents - include file contents in the resultant object
 * @returns {Promise<Object>}
 */
function readAndGetFileHash(file) {
    var returnFileContents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    return new _promise2.default(function (resolve, reject) {
        _fs2.default.readFile(file, function (err, data) {
            if (err) {
                reject(err);
                return;
            }
            var hash = _crypto2.default.createHash('sha1');
            hash.update(data);
            var returnObject = { hash: hash.digest('hex') };
            if (returnFileContents) {
                returnObject.contents = data.toString('utf8');
            }
            resolve(returnObject);
        });
    });
}

/**
 * Calculates a hash from objects values in specified order.
 * @param {Array} orderOfKeys
 * @param {Object} hashSet
 * @param {Function} keyFilter
 * @returns {string}
 */
function computeHashForHashesSet(orderOfKeys, hashSet) {
    var keyFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (key) {
        return key;
    };

    var hash = _crypto2.default.createHash('sha1');
    var hashesJoined = orderOfKeys.reduce(
    // eslint-disable-next-line no-param-reassign
    function (tmpHash, key) {
        return tmpHash += hashSet[keyFilter(key)], tmpHash;
    }, '');
    hash.update(hashesJoined);
    return hash.digest('hex');
}

/**
 * Reads files from disk and computes hashes for them.
 * @param {Array} files - array with file paths
 * @returns {Promise<Object>}
 */
function readAndHashFiles(files, fileFilter) {
    var fileHashes = {};
    var fileContents = {};
    var promises = [];

    function readSingleFile(file) {
        return new _promise2.default(function (resolve, reject) {
            readAndGetFileHash(file, file.endsWith('.js') && !file.endsWith('.test.js')).then(function (result) {
                if (fileFilter) {
                    file = fileFilter(file);
                }
                fileHashes[file] = result.hash;
                if (result.contents) {
                    fileContents[file] = result.contents;
                }
                resolve();
            }).catch(reject);
        });
    }

    files.forEach(function (file) {
        promises.push(readSingleFile(file));
    });

    return new _promise2.default(function (resolve, reject) {
        _promise2.default.all(promises).then(function () {
            resolve({ files: files, fileContents: fileContents, fileHashes: fileHashes });
        }).catch(reject);
    });
}

/**
 * Reads files from .desktop and computes a version hash.
 *
 * @param {string} dir - path
 * @param {Function} fileFilter
 * @returns {Promise<Object>}
 */
function readFilesAndComputeHash(dir, fileFilter) {
    return new _promise2.default(function (resolve, reject) {
        getFileList(dir, true).catch(reject).then(function (files) {
            return readAndHashFiles(files, fileFilter);
        }).catch(reject).then(function (result) {
            result.hash = computeHashForHashesSet(result.files, result.fileHashes, fileFilter);
            resolve(result);
        });
    });
}

exports.default = {
    getFileList: getFileList, rmWithRetries: rmWithRetries, exists: exists, readDir: readDir, readAndGetFileHash: readAndGetFileHash, computeHashForHashesSet: computeHashForHashesSet,
    readAndHashFiles: readAndHashFiles, readFilesAndComputeHash: readFilesAndComputeHash
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2xpYi91dGlscy5qcyJdLCJuYW1lcyI6WyJleGlzdHMiLCJybVdpdGhSZXRyaWVzIiwicmVhZERpciIsImdldEZpbGVMaXN0IiwicmVhZEFuZEdldEZpbGVIYXNoIiwiY29tcHV0ZUhhc2hGb3JIYXNoZXNTZXQiLCJyZWFkQW5kSGFzaEZpbGVzIiwicmVhZEZpbGVzQW5kQ29tcHV0ZUhhc2giLCJwYXRoVG9DaGVjayIsImFjY2Vzc1N5bmMiLCJlIiwiYXJncyIsInJldHJpZXMiLCJyZXNvbHZlIiwicmVqZWN0Iiwicm0iLCJybUFyZ3MiLCJjb25maWciLCJmYXRhbCIsInJlc2V0Iiwic2V0VGltZW91dCIsImRpciIsImNhbGxiYWNrIiwiZXJyIiwiZGF0YSIsInN0YXRzIiwibGlzdCIsImFsbFN0YXRzIiwicmVhZGRpciIsImZpbGVzIiwicGVuZGluZyIsImxlbmd0aCIsImZvckVhY2giLCJmaWxlIiwiZmlsZVBhdGgiLCJqb2luIiwic3RhdCIsIl9lcnIiLCJpc0RpcmVjdG9yeSIsIl9fZXJyIiwicmVzIiwiX2FsbFN0YXRzIiwiY29uY2F0IiwicHVzaCIsInNpemUiLCJkYXRlcyIsImF0aW1lIiwiZ2V0VGltZSIsImJpcnRodGltZSIsImN0aW1lIiwibXRpbWUiLCJzb3J0IiwiZXJyb3IiLCJyZXR1cm5GaWxlQ29udGVudHMiLCJyZWFkRmlsZSIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwicmV0dXJuT2JqZWN0IiwiZGlnZXN0IiwiY29udGVudHMiLCJ0b1N0cmluZyIsIm9yZGVyT2ZLZXlzIiwiaGFzaFNldCIsImtleUZpbHRlciIsImtleSIsImhhc2hlc0pvaW5lZCIsInJlZHVjZSIsInRtcEhhc2giLCJmaWxlRmlsdGVyIiwiZmlsZUhhc2hlcyIsImZpbGVDb250ZW50cyIsInByb21pc2VzIiwicmVhZFNpbmdsZUZpbGUiLCJlbmRzV2l0aCIsInRoZW4iLCJyZXN1bHQiLCJjYXRjaCIsImFsbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7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MEJBQVQsRUFBdUJELHNCQUF2QixFQUFSO0FBQ0gsU0FITCxFQUlLTyxLQUpMLENBSVcvRCxNQUpYO0FBS0gsS0FOTSxDQUFQO0FBT0g7O0FBRUQ7Ozs7Ozs7QUFPTyxTQUFTUCx1QkFBVCxDQUFpQ2MsR0FBakMsRUFBc0NnRCxVQUF0QyxFQUFrRDtBQUNyRCxXQUFPLHNCQUFZLFVBQUN4RCxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDcENYLG9CQUFZa0IsR0FBWixFQUFpQixJQUFqQixFQUNLd0QsS0FETCxDQUNXL0QsTUFEWCxFQUVLNkQsSUFGTCxDQUVVO0FBQUEsbUJBQVNyRSxpQkFBaUJ1QixLQUFqQixFQUF3QndDLFVBQXhCLENBQVQ7QUFBQSxTQUZWLEVBR0tRLEtBSEwsQ0FHVy9ELE1BSFgsRUFJSzZELElBSkwsQ0FJVSxVQUFDQyxNQUFELEVBQVk7QUFDZEEsbUJBQU9yQixJQUFQLEdBQWNsRCx3QkFBd0J1RSxPQUFPL0MsS0FBL0IsRUFBc0MrQyxPQUFPTixVQUE3QyxFQUF5REQsVUFBekQsQ0FBZDtBQUNBeEQsb0JBQVErRCxNQUFSO0FBQ0gsU0FQTDtBQVFILEtBVE0sQ0FBUDtBQVVIOztrQkFJYztBQUNYekUsNEJBRFcsRUFDRUYsNEJBREYsRUFDaUJELGNBRGpCLEVBQ3lCRSxnQkFEekIsRUFDa0NFLHNDQURsQyxFQUNzREMsZ0RBRHREO0FBRVhDLHNDQUZXLEVBRU9DO0FBRlAsQyIsImZpbGUiOiJ1dGlscy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgc2hlbGwgZnJvbSAnc2hlbGxqcyc7XG5cbi8qKlxuICogRXhpc3RzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFRvQ2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKHBhdGhUb0NoZWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZnMuYWNjZXNzU3luYyhwYXRoVG9DaGVjayk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTaW1wbGUgd3JhcHBlciBmb3Igc2hlbGxqcy5ybSB3aXRoIGFkZGl0aW9uYWwgcmV0cmllcyBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gKiBJdCBpcyB1c2VmdWwgd2hlbiBzb21ldGhpbmcgaXMgY29uY3VycmVudGx5IHJlYWRpbmcgdGhlIGRpciB5b3Ugd2FudCB0byByZW1vdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBybVdpdGhSZXRyaWVzKC4uLmFyZ3MpIHtcbiAgICBsZXQgcmV0cmllcyA9IDA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnVuY3Rpb24gcm0oLi4ucm1BcmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNoZWxsLmNvbmZpZy5mYXRhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2hlbGwucm0oLi4ucm1BcmdzKTtcbiAgICAgICAgICAgICAgICBzaGVsbC5jb25maWcucmVzZXQoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzIDwgNSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJtKC4uLnJtQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2hlbGwuY29uZmlnLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm0oLi4uYXJncyk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkRGlyKGRpciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICByZWFkRGlyKGRpciwgKGVyciwgZGF0YSwgc3RhdHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBkYXRhLCBzdGF0cyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBsaXN0ID0gW107XG4gICAgbGV0IGFsbFN0YXRzID0ge307XG5cbiAgICBmcy5yZWFkZGlyKGRpciwgKGVyciwgZmlsZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBlbmRpbmcgPSBmaWxlcy5sZW5ndGg7XG4gICAgICAgIGlmICghcGVuZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGxpc3QsIGFsbFN0YXRzKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxlcy5mb3JFYWNoKChmaWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihkaXIsIGZpbGUpO1xuICAgICAgICAgICAgZnMuc3RhdChmaWxlUGF0aCwgKF9lcnIsIHN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKF9lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKF9lcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkRGlyKGZpbGVQYXRoLCAoX19lcnIsIHJlcywgX2FsbFN0YXRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soX19lcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGxpc3QuY29uY2F0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxTdGF0cyA9IE9iamVjdC5hc3NpZ24oYWxsU3RhdHMsIF9hbGxTdGF0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbGlzdCwgYWxsU3RhdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goZmlsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBhbGxTdGF0c1tmaWxlUGF0aF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzdGF0cy5zaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5hdGltZS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuYmlydGh0aW1lLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5jdGltZS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMubXRpbWUuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbGlzdCwgYWxsU3RhdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmaWxlIGxpc3QgZnJvbSBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgLSBkaXIgcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBzb3J0IC0gd2hldGhlciB0byBhcHBseSBzb3J0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlTGlzdChkaXIsIHNvcnQgPSBmYWxzZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlYWREaXIoZGlyLCAoZXJyb3IsIGZpbGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgaWYgKHNvcnQpIHsgZmlsZXMgPSBmaWxlcy5zb3J0KCk7IH1cbiAgICAgICAgICAgIHJlc29sdmUoZmlsZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZpbGUncyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgLSBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuRmlsZUNvbnRlbnRzIC0gaW5jbHVkZSBmaWxlIGNvbnRlbnRzIGluIHRoZSByZXN1bHRhbnQgb2JqZWN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEFuZEdldEZpbGVIYXNoKGZpbGUsIHJldHVybkZpbGVDb250ZW50cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZnMucmVhZEZpbGUoZmlsZSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpO1xuICAgICAgICAgICAgaGFzaC51cGRhdGUoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5PYmplY3QgPSB7IGhhc2g6IGhhc2guZGlnZXN0KCdoZXgnKSB9O1xuICAgICAgICAgICAgaWYgKHJldHVybkZpbGVDb250ZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybk9iamVjdC5jb250ZW50cyA9IGRhdGEudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUocmV0dXJuT2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBhIGhhc2ggZnJvbSBvYmplY3RzIHZhbHVlcyBpbiBzcGVjaWZpZWQgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBvcmRlck9mS2V5c1xuICogQHBhcmFtIHtPYmplY3R9IGhhc2hTZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleUZpbHRlclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIYXNoRm9ySGFzaGVzU2V0KG9yZGVyT2ZLZXlzLCBoYXNoU2V0LCBrZXlGaWx0ZXIgPSBrZXkgPT4ga2V5KSB7XG4gICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgY29uc3QgaGFzaGVzSm9pbmVkID0gb3JkZXJPZktleXMucmVkdWNlKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgKHRtcEhhc2gsIGtleSkgPT4gKHRtcEhhc2ggKz0gaGFzaFNldFtrZXlGaWx0ZXIoa2V5KV0sIHRtcEhhc2gpLCAnJ1xuICAgICk7XG4gICAgaGFzaC51cGRhdGUoaGFzaGVzSm9pbmVkKTtcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpO1xufVxuXG5cbi8qKlxuICogUmVhZHMgZmlsZXMgZnJvbSBkaXNrIGFuZCBjb21wdXRlcyBoYXNoZXMgZm9yIHRoZW0uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWxlcyAtIGFycmF5IHdpdGggZmlsZSBwYXRoc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRBbmRIYXNoRmlsZXMoZmlsZXMsIGZpbGVGaWx0ZXIpIHtcbiAgICBjb25zdCBmaWxlSGFzaGVzID0ge307XG4gICAgY29uc3QgZmlsZUNvbnRlbnRzID0ge307XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHJlYWRTaW5nbGVGaWxlKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJlYWRBbmRHZXRGaWxlSGFzaChmaWxlLCBmaWxlLmVuZHNXaXRoKCcuanMnKSAmJiAhZmlsZS5lbmRzV2l0aCgnLnRlc3QuanMnKSlcbiAgICAgICAgICAgICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlID0gZmlsZUZpbHRlcihmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaWxlSGFzaGVzW2ZpbGVdID0gcmVzdWx0Lmhhc2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY29udGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVDb250ZW50c1tmaWxlXSA9IHJlc3VsdC5jb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBwcm9taXNlcy5wdXNoKHJlYWRTaW5nbGVGaWxlKGZpbGUpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBmaWxlcywgZmlsZUNvbnRlbnRzLCBmaWxlSGFzaGVzIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpbGVzIGZyb20gLmRlc2t0b3AgYW5kIGNvbXB1dGVzIGEgdmVyc2lvbiBoYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXIgLSBwYXRoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWxlRmlsdGVyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZEZpbGVzQW5kQ29tcHV0ZUhhc2goZGlyLCBmaWxlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZ2V0RmlsZUxpc3QoZGlyLCB0cnVlKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgICAgIC50aGVuKGZpbGVzID0+IHJlYWRBbmRIYXNoRmlsZXMoZmlsZXMsIGZpbGVGaWx0ZXIpKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaGFzaCA9IGNvbXB1dGVIYXNoRm9ySGFzaGVzU2V0KHJlc3VsdC5maWxlcywgcmVzdWx0LmZpbGVIYXNoZXMsIGZpbGVGaWx0ZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGdldEZpbGVMaXN0LCBybVdpdGhSZXRyaWVzLCBleGlzdHMsIHJlYWREaXIsIHJlYWRBbmRHZXRGaWxlSGFzaCwgY29tcHV0ZUhhc2hGb3JIYXNoZXNTZXQsXG4gICAgcmVhZEFuZEhhc2hGaWxlcywgcmVhZEZpbGVzQW5kQ29tcHV0ZUhhc2hcbn07XG4iXX0=